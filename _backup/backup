<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Mood Board</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* CSS variables will be set dynamically by JavaScript */
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: var(--bg-page);
        }
        canvas {
            display: block;
            background-color: var(--bg-canvas);
            cursor: grab;
        }
        canvas.grabbing {
            cursor: grabbing;
        }
        #context-menu {
            position: absolute;
            z-index: 1000;
            background-color: var(--bg-ui);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            padding: 0.75rem;
            display: none;
            width: 240px;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .menu-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.4rem 0.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .menu-item .text-red-500 {
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        .menu-item:hover {
            background-color: var(--bg-ui-hover);
        }
        .menu-label {
            font-size: 0.875rem;
            color: var(--text-color);
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 38px;
            height: 22px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-color);
            transition: .4s;
            border-radius: 22px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input:checked + .slider {
            background-color: var(--switch-bg-checked);
        }
        input:checked + .slider:before {
            transform: translateX(16px);
        }
        .tool-button {
            background-color: var(--bg-ui);
            border: 1px solid var(--border-color);
            border-radius: 0.375rem;
            padding: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            color: var(--text-color);
        }
        .tool-button:hover {
            background-color: var(--bg-ui-hover);
        }
        .tool-button.active {
            background-color: var(--bg-ui-hover);
            border-color: var(--switch-bg-checked);
            color: var(--switch-bg-checked);
        }
        #left-bar {
            position: absolute;
            top: 50%;
            left: 1rem;
            transform: translateY(-50%);
            z-index: 50;
            background-color: var(--bg-ui);
            padding: 0.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            border: 1px solid var(--border-color);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .slider-input {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            flex-grow: 1;
            height: 8px;
            background: var(--border-color);
            border-radius: 9999px;
            cursor: pointer;
        }
        .slider-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 1rem;
            height: 1rem;
            background: var(--switch-bg-checked);
            cursor: pointer;
            border-radius: 50%;
        }
        .slider-value-box {
            background-color: var(--bg-ui-hover);
            color: var(--text-color);
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            min-width: 50px;
            text-align: center;
        }
        .color-picker-input {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 2rem;
            height: 2rem;
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            border-radius: 0.375rem;
            overflow: hidden;
        }
        .color-picker-input::-webkit-color-swatch {
            border-radius: 0.375rem;
            border: 1px solid var(--border-color);
        }
        .color-picker-input::-moz-color-swatch {
            border-radius: 0.375rem;
            border: 1px solid var(--border-color);
        }
        #instructions-footer {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            z-index: 50;
            padding: 0.5rem 0.75rem;
            font-size: 0.75rem; /* small size */
            color: var(--text-color-light);
            background-color: var(--bg-ui);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            transition: background-color 0.3s ease-in-out;
            pointer-events: auto;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        #instructions-footer:hover {
            background-color: var(--bg-ui-hover);
        }
        #selection-toolbar {
            position: absolute;
            z-index: 1001;
            background-color: var(--bg-ui);
            padding: 0.35rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            display: flex;
            gap: 0.35rem;
            border: 1px solid var(--border-color);
            transform: translate(-50%, 10px); /* Position adjustment */
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .selection-tool-btn {
            background-color: transparent;
            border: none;
            border-radius: 0.375rem;
            padding: 0.4rem;
            cursor: pointer;
            color: var(--text-color);
            transition: all 0.2s;
        }
        .selection-tool-btn:hover {
            background-color: var(--bg-ui-hover);
        }
        .selection-tool-btn.active {
            background-color: var(--bg-ui-hover);
            color: var(--switch-bg-checked);
        }
        .selection-tool-btn.pinned {
            color: #f59e0b; /* Amber color for pinned */
        }
        #save-container {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            z-index: 50;
        }
        #text-editor {
            position: absolute;
            z-index: 1002;
            border: none;
            outline: none;
            padding: 10px;
            margin: 0;
            font-family: 'Inter', sans-serif;
            font-weight: bold;
            resize: none;
            overflow: hidden;
            box-sizing: border-box;
            line-height: 1.4;
        }
        #box-color-picker-container {
            position: absolute;
            z-index: 1001;
            display: none;
        }
        #box-color-picker {
             width: 24px;
             height: 24px;
             padding: 2px;
             border-radius: 50%;
             background-color: var(--bg-ui);
             border: 1px solid var(--border-color);
             box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>

    <canvas id="moodboard-canvas"></canvas>
    <input type="file" id="image-input" accept="image/*" style="display: none;" multiple>
    <textarea id="text-editor" style="display: none;"></textarea>

    <div id="left-bar">
         <button id="add-image-btn" title="Add Image (I)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 15 9 5 19"></polyline></svg>
        </button>
        <button id="add-text-btn" title="Add Text (T)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg>
        </button>
        <button id="add-arrow-btn" title="Add Arrow (A)" class="tool-button">
           <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>
        </button>
        <button id="add-box-btn" title="Add Box (B)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>
        </button>
    </div>

    <div id="context-menu">
        <div class="menu-item">
            <label class="menu-label">Colors</label>
            <div class="flex items-center gap-2">
                <input type="color" id="bg-color-picker" class="color-picker-input" value="#0d0d0d" title="Background Color">
                <input type="color" id="accent-color-picker" class="color-picker-input" value="#429eff" title="Accent Color">
                <input type="color" id="grid-color-picker" class="color-picker-input" value="#f9f8f6" title="Grid Color">
            </div>
        </div>
        <div class="menu-item">
            <label for="drop-shadow-toggle" class="menu-label">Drop Shadow</label>
            <label class="switch">
                <input type="checkbox" id="drop-shadow-toggle" checked>
                <span class="slider"></span>
            </label>
        </div>
        <div class="border-t my-2" style="border-color: var(--border-color);"></div>
        <div class="menu-item">
            <label for="show-grid-toggle" class="menu-label">Show Grid</label>
            <label class="switch">
                <input type="checkbox" id="show-grid-toggle" checked>
                <span class="slider"></span>
            </label>
        </div>
        <div class="menu-item">
            <label for="snap-grid-toggle" class="menu-label">Snap to Grid</label>
            <label class="switch">
                <input type="checkbox" id="snap-grid-toggle" checked>
                <span class="slider"></span>
            </label>
        </div>
        <div class="menu-item">
            <label for="grid-opacity-slider" class="menu-label">Grid Opacity</label>
            <div class="flex items-center gap-2" style="width: 60%;">
                <input type="range" id="grid-opacity-slider" min="0" max="1" step="0.05" value="0.05" class="slider-input">
                <div id="grid-opacity-value" class="slider-value-box">5%</div>
            </div>
        </div>
        <div class="menu-item">
            <label for="grid-size-slider" class="menu-label">Grid Size</label>
            <div class="flex items-center gap-2" style="width: 60%;">
                <input type="range" id="grid-size-slider" min="10" max="200" value="50" class="slider-input">
                <div id="grid-size-value" class="slider-value-box">50px</div>
            </div>
        </div>
         <div class="border-t my-2" id="delete-separator" style="border-color: var(--border-color);"></div>
         <div class="menu-item" id="delete-item-btn">
             <span class="menu-label text-red-500">Delete Selected</span>
             <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-red-500"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
         </div>
    </div>

    <div id="instructions-footer">
        Right-click for options | Scroll to zoom | Middle-click to pan
    </div>

    <div id="save-container">
        <button id="save-png-btn" title="Save as PNG (Shift+S)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>
        </button>
    </div>
    
    <div id="box-color-picker-container">
        <input type="color" id="box-color-picker" class="color-picker-input">
    </div>

    <div id="selection-toolbar" style="display: none;">
        <button id="scale-btn" class="selection-tool-btn" title="Scale (S)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 21l-6-6m6 6v-4m0 4h-4"/><path d="M3 3l6 6m-6-6v4m0-4h4"/></svg>
        </button>
        <button id="rotate-btn" class="selection-tool-btn" title="Rotate (R)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"/><path d="M1 20v-6h6"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>
        </button>
        <button id="pin-btn" class="selection-tool-btn" title="Pin (P)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.05A5 5 0 0 1 18 19.05M16 13l-6 6-4-4-6-6" /></svg>
        </button>
        <button id="delete-selection-btn" class="selection-tool-btn" title="Delete (Del)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-red-500"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
        </button>
    </div>


    <script>
        const canvas = document.getElementById('moodboard-canvas');
        const ctx = canvas.getContext('2d');
        const imageInput = document.getElementById('image-input');
        const addImageBtn = document.getElementById('add-image-btn');
        const addTextBtn = document.getElementById('add-text-btn');
        const addArrowBtn = document.getElementById('add-arrow-btn');
        const addBoxBtn = document.getElementById('add-box-btn');
        const contextMenu = document.getElementById('context-menu');
        const showGridToggle = document.getElementById('show-grid-toggle');
        const snapGridToggle = document.getElementById('snap-grid-toggle');
        const dropShadowToggle = document.getElementById('drop-shadow-toggle');
        const gridSizeSlider = document.getElementById('grid-size-slider');
        const gridSizeValue = document.getElementById('grid-size-value');
        const gridOpacitySlider = document.getElementById('grid-opacity-slider');
        const gridOpacityValue = document.getElementById('grid-opacity-value');
        const deleteItemBtn = document.getElementById('delete-item-btn');
        const savePngBtn = document.getElementById('save-png-btn');
        const bgColorPicker = document.getElementById('bg-color-picker');
        const accentColorPicker = document.getElementById('accent-color-picker');
        const gridColorPicker = document.getElementById('grid-color-picker');
        const textEditor = document.getElementById('text-editor');
        const boxColorPickerContainer = document.getElementById('box-color-picker-container');
        const boxColorPicker = document.getElementById('box-color-picker');
        const selectionToolbar = document.getElementById('selection-toolbar');
        const scaleBtn = document.getElementById('scale-btn');
        const rotateBtn = document.getElementById('rotate-btn');
        const pinBtn = document.getElementById('pin-btn');
        const deleteSelectionBtn = document.getElementById('delete-selection-btn');

        let cameraOffset = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let cameraZoom = 1;
        const MAX_ZOOM = 5, MIN_ZOOM = 0.1, SCROLL_SENSITIVITY = 0.0005;
        let isDragging = false, dragStart = { x: 0, y: 0 };
        let items = [], selectedItems = []; 
        let isMovingItems = false, moveStart = {x: 0, y: 0};
        let currentTool = null, isDrawing = false;
        let canvasBackgroundColor = '#0d0d0d', accentColor = '#429eff', gridColor = '#f9f8f6';
        let activeGizmo = null, isTransforming = false, isTransformingArrow = false;
        let transformingHandle = null, transformStart = { x: 0, y: 0 }, originalItemState = null;
        let hoveredGizmo = null, hoveredArrowHandle = null;
        let isSelectingBox = false, selectionBox = { startX: 0, startY: 0, endX: 0, endY: 0 };
        let currentlyEditingText = null;
        let showGrid = true, snapToGrid = true, showDropShadow = true;
        let gridSize = 50, gridOpacity = 0.05;

        function setupEventListeners() {
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('dblclick', onDoubleClick);
            canvas.addEventListener('wheel', (e) => { e.preventDefault(); adjustZoom(e, -e.deltaY * SCROLL_SENSITIVITY); });
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', handleKeyDown);
            canvas.addEventListener('contextmenu', onContextMenu);
            document.addEventListener('click', (e) => { if (!contextMenu.contains(e.target)) contextMenu.style.display = 'none'; });
            
            window.addEventListener('paste', handlePaste);
            canvas.addEventListener('dragover', handleDragOver);
            canvas.addEventListener('dragleave', handleDragLeave);
            canvas.addEventListener('drop', handleDrop);

            savePngBtn.addEventListener('click', saveAsPng);
            addImageBtn.addEventListener('click', () => imageInput.click());
            imageInput.addEventListener('change', handleImageUpload);
            addArrowBtn.addEventListener('click', () => setCurrentTool('arrow'));
            addTextBtn.addEventListener('click', () => setCurrentTool('text'));
            addBoxBtn.addEventListener('click', () => setCurrentTool('box'));
            
            showGridToggle.addEventListener('change', (e) => showGrid = e.target.checked);
            snapGridToggle.addEventListener('change', (e) => snapToGrid = e.target.checked);
            dropShadowToggle.addEventListener('change', (e) => showDropShadow = e.target.checked);
            gridSizeSlider.addEventListener('input', (e) => { gridSize = parseInt(e.target.value); gridSizeValue.textContent = `${gridSize}px`; });
            gridOpacitySlider.addEventListener('input', (e) => { gridOpacity = parseFloat(e.target.value); gridOpacityValue.textContent = `${Math.round(gridOpacity * 100)}%`; });
            deleteItemBtn.addEventListener('click', deleteSelectedItems);
            bgColorPicker.addEventListener('input', e => { canvasBackgroundColor = e.target.value; canvas.style.backgroundColor = canvasBackgroundColor; updateUIColors(); });
            accentColorPicker.addEventListener('input', e => { accentColor = e.target.value; updateUIColors(); });
            gridColorPicker.addEventListener('input', e => { gridColor = e.target.value; });

            scaleBtn.addEventListener('click', () => setActiveGizmo('scale'));
            rotateBtn.addEventListener('click', () => setActiveGizmo('rotate'));
            pinBtn.addEventListener('click', togglePin);
            deleteSelectionBtn.addEventListener('click', deleteSelectedItems);

            textEditor.addEventListener('blur', finishEditingText);
            textEditor.addEventListener('keydown', (e) => { if (e.key === 'Escape') finishEditingText(); });
            
            boxColorPicker.addEventListener('input', (e) => {
                if(selectedItems.length === 1 && selectedItems[0].type === 'box'){
                    selectedItems[0].color = e.target.value;
                }
            });
        }
        
        function updateUIColors() {
            const [accentH, accentS, accentL] = hexToHsl(accentColor);
            const [bgH, bgS, bgL] = hexToHsl(canvasBackgroundColor);
            const uiLuminosity = Math.max(0.1, Math.min(0.9, 1.0 - bgL));
            const uiSaturation = Math.min(accentS, 0.6); 
            const [uiR, uiG, uiB] = hslToRgb(accentH, uiSaturation, uiLuminosity);
            const uiBgColor = `rgba(${uiR}, ${uiG}, ${uiB}, 0.5)`;
            const hoverLuminosity = uiLuminosity + (uiLuminosity > 0.5 ? -0.1 : 0.1);
            const [hvrR, hvrG, hvrB] = hslToRgb(accentH, uiSaturation, hoverLuminosity);
            const uiBgHoverColor = `rgba(${hvrR}, ${hvrG}, ${hvrB}, 0.65)`;
            const textColor = uiLuminosity > 0.55 ? '#0f172a' : '#f8fafc';
            const textLightColor = uiLuminosity > 0.55 ? '#334155' : '#94a3b8';
            const borderColor = hslToHex(accentH, uiSaturation, uiLuminosity + (uiLuminosity > 0.5 ? -0.15 : 0.15));
            const rootStyle = document.documentElement.style;
            rootStyle.setProperty('--bg-page', canvasBackgroundColor);
            rootStyle.setProperty('--bg-ui', uiBgColor);
            rootStyle.setProperty('--bg-ui-hover', uiBgHoverColor);
            rootStyle.setProperty('--text-color', textColor);
            rootStyle.setProperty('--text-color-light', textLightColor);
            rootStyle.setProperty('--text-color-strong', textColor);
            rootStyle.setProperty('--border-color', borderColor);
            rootStyle.setProperty('--switch-bg-checked', accentColor);
        }

        function setCurrentTool(tool) {
            currentTool = currentTool === tool ? null : tool;
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            if (currentTool === 'arrow') addArrowBtn.classList.add('active');
            if (currentTool === 'text') addTextBtn.classList.add('active');
            if (currentTool === 'box') addBoxBtn.classList.add('active');
        }

        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }

        function draw() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.translate(window.innerWidth / 2, window.innerHeight / 2);
            ctx.scale(cameraZoom, cameraZoom);
            ctx.translate(-window.innerWidth / 2 + cameraOffset.x, -window.innerHeight / 2 + cameraOffset.y);
            if (showGrid) drawGrid();
            items.forEach(item => {
                if(item.isHidden) return;
                ctx.save();
                if (showDropShadow) {
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                    ctx.shadowBlur = 15 / cameraZoom;
                    ctx.shadowOffsetX = 4 / cameraZoom;
                    ctx.shadowOffsetY = 4 / cameraZoom;
                }
                if(item.type === 'image') {
                    const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
                    ctx.translate(centerX, centerY);
                    ctx.rotate(item.rotation);
                    ctx.translate(-centerX, -centerY);
                    ctx.drawImage(item.img, item.x, item.y, item.width, item.height);
                } else if (item.type === 'arrow') {
                    drawArrow(ctx, item);
                } else if (item.type === 'text') {
                    drawTextItem(ctx, item);
                } else if (item.type === 'box') {
                    drawBoxItem(ctx, item);
                }
                ctx.restore();
                if (selectedItems.includes(item)) drawSelection(item);
            });
            if(isSelectingBox) drawSelectionBox();
        }

        function drawSelection(item) {
            if (selectedItems.length !== 1) { drawSelectionOutline(item); return; }
            if (item.type === 'arrow' && !item.isPinned) {
                 const handleSize = 8 / cameraZoom, gizmoColor = invertColor(canvasBackgroundColor);
                ctx.save();
                ctx.fillStyle = gizmoColor;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 4 / cameraZoom;
                ctx.beginPath();
                ctx.arc(item.startX, item.startY, handleSize, 0, Math.PI * 2);
                ctx.fill();
                if (hoveredArrowHandle === 'start') { ctx.strokeStyle = accentColor; ctx.lineWidth = 2 / cameraZoom; ctx.stroke(); }
                ctx.beginPath();
                ctx.arc(item.endX, item.endY, handleSize, 0, Math.PI * 2);
                ctx.fill();
                if (hoveredArrowHandle === 'end') { ctx.strokeStyle = accentColor; ctx.lineWidth = 2 / cameraZoom; ctx.stroke(); }
                ctx.restore();
                return; 
            }
            ctx.save();
            const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
            ctx.translate(centerX, centerY);
            ctx.rotate(item.rotation);
            ctx.strokeStyle = accentColor;
            ctx.lineWidth = 2 / cameraZoom;
            ctx.strokeRect(-item.width / 2, -item.height / 2, item.width, item.height);
            if (activeGizmo && !item.isPinned) {
                const gizmoColor = invertColor(canvasBackgroundColor), handleSize = 8 / cameraZoom;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 4 / cameraZoom;
                ctx.fillStyle = gizmoColor;
                ctx.strokeStyle = gizmoColor;
                if (activeGizmo === 'scale') {
                    const cornerX = item.width / 2, cornerY = item.height / 2;
                    ctx.beginPath();
                    ctx.arc(cornerX, cornerY, handleSize, 0, Math.PI * 2);
                    ctx.fill();
                    if (hoveredGizmo === 'scale') { ctx.strokeStyle = accentColor; ctx.lineWidth = 2 / cameraZoom; ctx.stroke(); }
                } else if (activeGizmo === 'rotate') {
                    const cornerX = item.width / 2, cornerY = -item.height / 2;
                    const handleX = cornerX, handleY = cornerY - 20 / cameraZoom;
                    ctx.beginPath();
                    ctx.moveTo(cornerX, cornerY);
                    ctx.lineTo(handleX, handleY);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(handleX, handleY, handleSize, 0, Math.PI * 2);
                    ctx.fill();
                    if (hoveredGizmo === 'rotate') { ctx.strokeStyle = accentColor; ctx.lineWidth = 2 / cameraZoom; ctx.stroke(); }
                }
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        function drawSelectionOutline(item) {
            ctx.save();
            const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
            ctx.translate(centerX, centerY);
            ctx.rotate(item.rotation);
            ctx.strokeStyle = accentColor;
            ctx.lineWidth = 2 / cameraZoom;
            ctx.strokeRect(-item.width / 2, -item.height / 2, item.width, item.height);
            ctx.restore();
        }

        function drawSelectionBox() {
            ctx.save();
            ctx.fillStyle = hexToRgba(accentColor, 0.1);
            ctx.strokeStyle = accentColor;
            ctx.lineWidth = 1 / cameraZoom;
            const { x, y, width, height } = getNormalizedSelectionBox();
            ctx.fillRect(x, y, width, height);
            ctx.strokeRect(x, y, width, height);
            ctx.restore();
        }

        function drawGrid() {
            const worldLeft = (0 - window.innerWidth / 2) / cameraZoom + (window.innerWidth / 2 - cameraOffset.x);
            const worldTop = (0 - window.innerHeight / 2) / cameraZoom + (window.innerHeight / 2 - cameraOffset.y);
            const worldRight = (window.innerWidth - window.innerWidth / 2) / cameraZoom + (window.innerWidth / 2 - cameraOffset.x);
            const worldBottom = (window.innerHeight - window.innerHeight / 2) / cameraZoom + (window.innerHeight / 2 - cameraOffset.y);
            const startX = Math.floor(worldLeft / gridSize) * gridSize, startY = Math.floor(worldTop / gridSize) * gridSize;
            ctx.save();
            ctx.globalAlpha = gridOpacity;
            ctx.beginPath();
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1 / cameraZoom;
            for (let x = startX; x < worldRight; x += gridSize) { ctx.moveTo(x, worldTop); ctx.lineTo(x, worldBottom); }
            for (let y = startY; y < worldBottom; y += gridSize) { ctx.moveTo(worldLeft, y); ctx.lineTo(worldRight, y); }
            ctx.stroke();
            ctx.restore();
        }
        
        function drawArrow(context, arrow) {
            const headlen = 10, dx = arrow.endX - arrow.startX, dy = arrow.endY - arrow.startY;
            const angle = Math.atan2(dy, dx);
            context.beginPath();
            context.moveTo(arrow.startX, arrow.startY);
            context.lineTo(arrow.endX, arrow.endY);
            context.lineTo(arrow.endX - headlen * Math.cos(angle - Math.PI / 6), arrow.endY - headlen * Math.sin(angle - Math.PI / 6));
            context.moveTo(arrow.endX, arrow.endY);
            context.lineTo(arrow.endX - headlen * Math.cos(angle + Math.PI / 6), arrow.endY - headlen * Math.sin(angle + Math.PI / 6));
            context.strokeStyle = accentColor;
            context.lineWidth = 3;
            context.stroke();
        }

        function drawTextItem(context, item) {
            context.save();
            const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
            context.translate(centerX, centerY);
            context.rotate(item.rotation);
            context.translate(-centerX, -centerY);
            context.globalAlpha = 0.05;
            context.fillStyle = accentColor;
            context.fillRect(item.x, item.y, item.width, item.height);
            context.globalAlpha = 1.0;
            context.fillStyle = accentColor;
            context.font = `bold ${item.fontSize}px 'Inter', sans-serif`;
            context.textAlign = 'left';
            context.textBaseline = 'top';
            const words = item.text.split(' ');
            let line = '', padding = 10, textY = item.y + padding, lineHeight = item.fontSize * 1.4;
            for(let n = 0; n < words.length; n++) {
                let testLine = line + words[n] + ' ', metrics = context.measureText(testLine), testWidth = metrics.width;
                if (testWidth > item.width - padding * 2 && n > 0) {
                    context.fillText(line, item.x + padding, textY);
                    line = words[n] + ' ';
                    textY += lineHeight;
                } else { line = testLine; }
            }
            context.fillText(line, item.x + padding, textY);
            context.restore();
        }

        function drawBoxItem(context, item) {
             context.save();
            const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
            context.translate(centerX, centerY);
            context.rotate(item.rotation);
            context.translate(-centerX, -centerY);
            context.fillStyle = item.color;
            context.fillRect(item.x, item.y, item.width, item.height);
            context.restore();
        }

        function handleKeyDown(e) {
            const key = e.key.toLowerCase();
            if (currentlyEditingText) return;
            if(e.ctrlKey && key === 'a') { e.preventDefault(); selectedItems = [...items]; updateSelectionToolbar(); return; }
            if (e.shiftKey && key === 's') { e.preventDefault(); saveAsPng(); return; }
            if (key === 'g') { e.preventDefault(); showGrid = !showGrid; showGridToggle.checked = showGrid; return; }
            if (key === 'a') { e.preventDefault(); setCurrentTool('arrow'); return; }
            if (key === 't') { e.preventDefault(); setCurrentTool('text'); return; }
            if (key === 'i') { e.preventDefault(); imageInput.click(); return; }
            if (key === 'b') { e.preventDefault(); setCurrentTool('box'); return; }
            if (selectedItems.length === 0) return;
            if (key === 'delete' || key === 'backspace') { e.preventDefault(); deleteSelectedItems(); return; }
            if(selectedItems.length !== 1) return;
            const selectedItem = selectedItems[0];
            e.preventDefault();
            if (key === 'p') { togglePin(); return; }
            if (selectedItem.isPinned) return;
            switch (key) {
                case 'r': setActiveGizmo('rotate'); break;
                case 's': setActiveGizmo('scale'); break;
            }
        }

        function onDoubleClick(e) {
            const worldPos = screenToWorld(getEventLocation(e));
            const item = getItemAtPosition(worldPos);
            if (item && item.type === 'text' && !item.isPinned) editText(item);
        }
        
        function getEventLocation(e) { return { x: e.clientX, y: e.clientY }; }
        function screenToWorld(p) { return { x: (p.x - window.innerWidth / 2) / cameraZoom + (window.innerWidth / 2 - cameraOffset.x), y: (p.y - window.innerHeight / 2) / cameraZoom + (window.innerHeight / 2 - cameraOffset.y) }; }
        function worldToScreen(p) { return { x: (p.x - (window.innerWidth / 2 - cameraOffset.x)) * cameraZoom + window.innerWidth / 2, y: (p.y - (window.innerHeight / 2 - cameraOffset.y)) * cameraZoom + window.innerHeight / 2 }; }
        
        function getItemAtPosition(pos) {
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                if (item.type === 'arrow') {
                    if (Math.sqrt(distToSegmentSquared(pos, {x: item.startX, y: item.startY}, {x: item.endX, y: item.endY})) < 10 / cameraZoom) return item;
                } else { 
                    const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
                    const dx = pos.x - centerX, dy = pos.y - centerY, angle = -item.rotation;
                    const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle), rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);
                    if (rotatedX > -item.width / 2 && rotatedX < item.width / 2 && rotatedY > -item.height / 2 && rotatedY < item.height / 2) return item;
                }
            }
            return null;
        }

        function getGizmoAtPosition(worldPos) {
            if (selectedItems.length !== 1) return null;
            const selectedItem = selectedItems[0];
            if (!selectedItem || selectedItem.isPinned || selectedItem.type === 'arrow' || !activeGizmo) return null;
            const handleSize = 14 / cameraZoom, item = selectedItem, centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
            if (activeGizmo === 'rotate') {
                const rotDX = item.width / 2, rotDY = -item.height / 2 - 20 / cameraZoom;
                const rotX = rotDX * Math.cos(item.rotation) - rotDY * Math.sin(item.rotation), rotY = rotDX * Math.sin(item.rotation) + rotDY * Math.cos(item.rotation);
                if (Math.hypot(worldPos.x - (centerX + rotX), worldPos.y - (centerY + rotY)) < handleSize) return 'rotate';
            }
            if (activeGizmo === 'scale') {
                const scaleDX = item.width / 2, scaleDY = item.height / 2;
                const scaleX = scaleDX * Math.cos(item.rotation) - scaleDY * Math.sin(item.rotation), scaleY = scaleDX * Math.sin(item.rotation) + scaleDY * Math.cos(item.rotation);
                if (Math.hypot(worldPos.x - (centerX + scaleX), worldPos.y - (centerY + scaleY)) < handleSize) return 'scale';
            }
            return null;
        }

        function getArrowHandleAtPosition(worldPos) {
            if (selectedItems.length !== 1) return null;
            const selectedItem = selectedItems[0];
            if (!selectedItem || selectedItem.isPinned || selectedItem.type !== 'arrow') return null;
            const handleRadius = 12 / cameraZoom, item = selectedItem;
            if (Math.hypot(worldPos.x - item.startX, worldPos.y - item.startY) < handleRadius) return 'start';
            if (Math.hypot(worldPos.x - item.endX, worldPos.y - item.endY) < handleRadius) return 'end';
            return null;
        }

        function onMouseDown(e) {
            if (currentlyEditingText) { finishEditingText(); return; }
            const worldPos = screenToWorld(getEventLocation(e));
            if (e.button === 0) {
                if (selectedItems.length === 1 && selectedItems[0].type === 'arrow' && !selectedItems[0].isPinned) {
                    const handle = getArrowHandleAtPosition(worldPos);
                    if (handle) { isTransformingArrow = true; transformingHandle = handle; return; }
                }
                if (selectedItems.length === 1) {
                    const gizmo = getGizmoAtPosition(worldPos);
                    if (gizmo && selectedItems[0] && !selectedItems[0].isPinned) {
                        isTransforming = true; activeGizmo = gizmo; updateSelectionToolbar();
                        originalItemState = { ...selectedItems[0], centerX: selectedItems[0].x + selectedItems[0].width / 2, centerY: selectedItems[0].y + selectedItems[0].height / 2, startAngle: Math.atan2(worldPos.y - (selectedItems[0].y + selectedItems[0].height / 2), worldPos.x - (selectedItems[0].x + selectedItems[0].width / 2)), startDist: Math.hypot(worldPos.x - (selectedItems[0].x + selectedItems[0].width / 2), worldPos.y - (selectedItems[0].y + selectedItems[0].height / 2)), };
                        return;
                    }
                }
                if(currentTool) {
                    isDrawing = true;
                    if(currentTool === 'arrow') {
                        const newArrow = { id: Date.now(), type: 'arrow', startX: worldPos.x, startY: worldPos.y, endX: worldPos.x, endY: worldPos.y, rotation: 0, isPinned: false, x: worldPos.x, y: worldPos.y, width: 0, height: 0 };
                        items.push(newArrow); selectedItems = [newArrow];
                    } else if (currentTool === 'text') {
                        const newText = { id: Date.now(), type: 'text', text: 'Type...', x: worldPos.x, y: worldPos.y, width: 0, height: 0, fontSize: 32, rotation: 0, isPinned: false };
                        items.push(newText); selectedItems = [newText];
                    } else if (currentTool === 'box') {
                        const newBox = { id: Date.now(), type: 'box', color: accentColor, x: worldPos.x, y: worldPos.y, width: 0, height: 0, rotation: 0, isPinned: false };
                        items.push(newBox); selectedItems = [newBox];
                    }
                } else {
                    const newSelectedItem = getItemAtPosition(worldPos);
                    if (e.shiftKey) {
                         if (newSelectedItem) {
                            const index = selectedItems.findIndex(item => item.id === newSelectedItem.id);
                            if (index > -1) selectedItems.splice(index, 1); else selectedItems.push(newSelectedItem);
                        }
                    } else {
                        if (newSelectedItem) {
                            if (selectedItems.includes(newSelectedItem)) {
                                isMovingItems = true; moveStart.x = worldPos.x; moveStart.y = worldPos.y;
                                selectedItems.forEach(item => {
                                    item.originalX = item.x; item.originalY = item.y;
                                    if(item.type === 'arrow'){ item.originalStartX = item.startX; item.originalStartY = item.startY; item.originalEndX = item.endX; item.originalEndY = item.endY; }
                                });
                            } else {
                                selectedItems = [newSelectedItem]; isMovingItems = true;
                                moveStart.x = worldPos.x - newSelectedItem.x; moveStart.y = worldPos.y - newSelectedItem.y;
                            }
                        } else {
                            selectedItems = []; isSelectingBox = true;
                            selectionBox.startX = worldPos.x; selectionBox.startY = worldPos.y;
                            selectionBox.endX = worldPos.x; selectionBox.endY = worldPos.y;
                        }
                    }
                    updateSelectionToolbar();
                }
            } else if (e.button === 1) {
                isDragging = true; dragStart.x = getEventLocation(e).x / cameraZoom - cameraOffset.x; dragStart.y = getEventLocation(e).y / cameraZoom - cameraOffset.y; canvas.classList.add('grabbing');
            }
        }

        function onMouseUp(e) {
            if (e.button === 0) {
                if (isDrawing) {
                    isDrawing = false;
                    const item = selectedItems.length === 1 ? selectedItems[0] : null;
                    if (item && (item.type === 'text' || item.type === 'box')) {
                        if (item.width < 10 || item.height < 10) { items = items.filter(i => i.id !== item.id); selectedItems = []; } 
                        else if (item.type === 'text') { editText(item); }
                    }
                    setCurrentTool(null);
                }
                if (isSelectingBox) {
                    isSelectingBox = false;
                    const box = getNormalizedSelectionBox();
                    selectedItems = items.filter(item => rectsIntersect(getItemBoundingBox(item), box));
                    updateSelectionToolbar();
                }
                 isMovingItems = false; isTransforming = false; isTransformingArrow = false; transformingHandle = null; originalItemState = null;
            } else if (e.button === 1) { isDragging = false; canvas.classList.remove('grabbing'); }
        }

        function onMouseMove(e) {
            const worldPos = screenToWorld(getEventLocation(e));
            if(isSelectingBox){ selectionBox.endX = worldPos.x; selectionBox.endY = worldPos.y; return; }
            if (isTransformingArrow && selectedItems.length === 1) {
                const selectedItem = selectedItems[0];
                if (transformingHandle === 'start') { selectedItem.startX = worldPos.x; selectedItem.startY = worldPos.y; } else if (transformingHandle === 'end') { selectedItem.endX = worldPos.x; selectedItem.endY = worldPos.y; }
                return;
            }
            if (isTransforming && selectedItems.length === 1) {
                const selectedItem = selectedItems[0], centerX = originalItemState.centerX, centerY = originalItemState.centerY;
                if (activeGizmo === 'rotate') {
                    const currentAngle = Math.atan2(worldPos.y - centerY, worldPos.x - centerX);
                    let newRotation = originalItemState.rotation + (currentAngle - originalItemState.startAngle);
                    const snapAngle = e.shiftKey ? (Math.PI / 180) : (Math.PI / 12);
                    newRotation = Math.round(newRotation / snapAngle) * snapAngle;
                    selectedItem.rotation = newRotation;
                } else if (activeGizmo === 'scale') {
                    const currentDist = Math.hypot(worldPos.x - centerX, worldPos.y - centerY);
                    const scaleFactor = Math.max(0.1, currentDist / originalItemState.startDist);
                    selectedItem.width = originalItemState.width * scaleFactor;
                    selectedItem.height = originalItemState.height * scaleFactor;
                    selectedItem.x = centerX - selectedItem.width / 2;
                    selectedItem.y = centerY - selectedItem.height / 2;
                     if(selectedItem.type === 'text') selectedItem.fontSize = originalItemState.fontSize * scaleFactor;
                }
            } else if(isMovingItems && selectedItems.length > 0) {
                 const dx = worldPos.x - moveStart.x, dy = worldPos.y - moveStart.y;
                selectedItems.forEach(item => {
                    if (item.isPinned) return;
                    if (selectedItems.length > 1) {
                        let newX = item.originalX + dx, newY = item.originalY + dy;
                        const itemDx = newX - item.x, itemDy = newY - item.y;
                        if (item.type === 'arrow') { item.startX += itemDx; item.startY += itemDy; item.endX += itemDx; item.endY += itemDy; }
                        item.x = newX; item.y = newY;
                    } else {
                        let newX = worldPos.x - moveStart.x, newY = worldPos.y - moveStart.y;
                        if (snapToGrid) { newX = Math.round(newX / gridSize) * gridSize; newY = Math.round(newY / gridSize) * gridSize; }
                         if (item.type === 'arrow') {
                            const dxSingle = newX - item.x, dySingle = newY - item.y;
                            item.startX += dxSingle; item.startY += dySingle; item.endX += dxSingle; item.endY += dySingle;
                        }
                        item.x = newX; item.y = newY;
                    }
                });
            } else if (isDrawing && selectedItems.length === 1) {
                const selectedItem = selectedItems[0];
                 if(selectedItem.type === 'arrow') {
                    selectedItem.endX = worldPos.x; selectedItem.endY = worldPos.y;
                } else if(selectedItem.type === 'text' || selectedItem.type === 'box') {
                    selectedItem.width = worldPos.x - selectedItem.x; selectedItem.height = worldPos.y - selectedItem.y;
                    if (selectedItem.width < 0) { selectedItem.x = worldPos.x; selectedItem.width = Math.abs(selectedItem.width); }
                    if (selectedItem.height < 0) { selectedItem.y = worldPos.y; selectedItem.height = Math.abs(selectedItem.height); }
                }
            } else if (isDragging) {
                cameraOffset.x = getEventLocation(e).x / cameraZoom - dragStart.x; cameraOffset.y = getEventLocation(e).y / cameraZoom - dragStart.y;
            }
            if (!isDragging && !isMovingItems && !isTransforming && !isTransformingArrow) {
                const currentHoveredGizmo = getGizmoAtPosition(worldPos), currentHoveredArrowHandle = getArrowHandleAtPosition(worldPos);
                if (currentHoveredGizmo !== hoveredGizmo || currentHoveredArrowHandle !== hoveredArrowHandle) { hoveredGizmo = currentHoveredGizmo; hoveredArrowHandle = currentHoveredArrowHandle; }
                if (hoveredGizmo || hoveredArrowHandle) canvas.style.cursor = 'pointer';
                else if (getItemAtPosition(worldPos)) canvas.style.cursor = 'move';
                else if (currentTool) canvas.style.cursor = 'crosshair';
                else canvas.style.cursor = 'grab';
            }
        }
        
        function onContextMenu(e) {
            e.preventDefault();
            const itemUnderCursor = getItemAtPosition(screenToWorld(getEventLocation(e)));
            if (itemUnderCursor && !selectedItems.includes(itemUnderCursor)) { selectedItems = [itemUnderCursor]; updateSelectionToolbar(); }
            const deleteSeparator = document.getElementById('delete-separator');
            deleteItemBtn.style.display = selectedItems.length > 0 ? 'flex' : 'none';
            deleteSeparator.style.display = selectedItems.length > 0 ? 'block' : 'none';
            contextMenu.style.left = `${e.clientX}px`; contextMenu.style.top = `${e.clientY}px`; contextMenu.style.display = 'block';
        }
        
        function deleteSelectedItems() {
            if(selectedItems.length > 0) {
                const idsToDelete = new Set(selectedItems.map(item => item.id));
                items = items.filter(item => !idsToDelete.has(item.id));
                selectedItems = [];
                updateSelectionToolbar();
            }
        }

        function setActiveGizmo(gizmo) { activeGizmo = activeGizmo === gizmo ? null : gizmo; updateSelectionToolbar(); }
        function togglePin() { if (selectedItems.length === 1) { selectedItems[0].isPinned = !selectedItems[0].isPinned; updateSelectionToolbar(); } }

        function updateSelectionToolbar() {
            if (selectedItems.length === 1) {
                const selectedItem = selectedItems[0], isArrow = selectedItem.type === 'arrow', isBox = selectedItem.type === 'box';
                scaleBtn.style.display = isArrow ? 'none' : 'block';
                rotateBtn.style.display = isArrow ? 'none' : 'block';
                pinBtn.style.display = 'block';
                selectionToolbar.style.display = 'flex';
                scaleBtn.classList.toggle('active', activeGizmo === 'scale');
                rotateBtn.classList.toggle('active', activeGizmo === 'rotate');
                pinBtn.classList.toggle('pinned', selectedItem.isPinned);
                
                if(isBox && !selectedItem.isPinned) {
                    const screenPos = worldToScreen({x: selectedItem.x, y: selectedItem.y});
                    boxColorPickerContainer.style.display = 'block';
                    boxColorPicker.value = selectedItem.color;
                    boxColorPickerContainer.style.left = `${screenPos.x - (12 / cameraZoom)}px`;
                    boxColorPickerContainer.style.top = `${screenPos.y - (12 / cameraZoom)}px`;
                } else {
                    boxColorPickerContainer.style.display = 'none';
                }

            } else if (selectedItems.length > 1) {
                scaleBtn.style.display = 'none'; rotateBtn.style.display = 'none'; pinBtn.style.display = 'none';
                selectionToolbar.style.display = 'flex';
                boxColorPickerContainer.style.display = 'none';
            } else { 
                selectionToolbar.style.display = 'none'; activeGizmo = null; 
                boxColorPickerContainer.style.display = 'none';
            }
        }

        function updateToolbarPosition() {
             if (selectedItems.length === 1) {
                const item = selectedItems[0], centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
                const bottomCenterDX = 0, bottomCenterDY = item.height / 2;
                const rotatedX = bottomCenterDX * Math.cos(item.rotation) - bottomCenterDY * Math.sin(item.rotation);
                const rotatedY = bottomCenterDX * Math.sin(item.rotation) + bottomCenterDY * Math.cos(item.rotation);
                const anchorPointX = centerX + rotatedX, anchorPointY = centerY + rotatedY;
                const screenPos = worldToScreen({ x: anchorPointX, y: anchorPointY });
                selectionToolbar.style.left = `${screenPos.x}px`; selectionToolbar.style.top = `${screenPos.y}px`;
                
                if(item.type === 'box' && !item.isPinned){
                    const boxTopLeft = worldToScreen({x: item.x, y: item.y});
                    boxColorPickerContainer.style.left = `${boxTopLeft.x - 12}px`;
                    boxColorPickerContainer.style.top = `${boxTopLeft.y - 12}px`;
                }

            } else { selectionToolbar.style.display = 'none'; boxColorPickerContainer.style.display = 'none'; }
        }

        function handleImageUpload(event) {
            const files = event.target.files;
            if (!files) return;
            const worldPos = screenToWorld({x: window.innerWidth / 2, y: window.innerHeight / 2});
            processFiles(files, worldPos);
            imageInput.value = '';
        }
        function handlePaste(e) {
            const files = []; const clipItems = e.clipboardData.items;
            for (let i = 0; i < clipItems.length; i++) { if (clipItems[i].type.indexOf('image') !== -1) files.push(clipItems[i].getAsFile()); }
            if (files.length > 0) processFiles(files, screenToWorld({ x: window.innerWidth / 2, y: window.innerHeight / 2 }));
        }
        function handleDragOver(e) { e.preventDefault(); canvas.style.outline = `2px dashed ${accentColor}`; canvas.style.outlineOffset = '-10px'; }
        function handleDragLeave(e) { e.preventDefault(); canvas.style.outline = 'none'; canvas.style.outlineOffset = '0px'; }
        function handleDrop(e) { e.preventDefault(); handleDragLeave(e); if (e.dataTransfer.files) processFiles(e.dataTransfer.files, screenToWorld({ x: e.clientX, y: e.clientY })); }
        function processFiles(files, worldPos) {
             Array.from(files).forEach((file, index) => {
                if (!file.type.startsWith('image/')) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const aspectRatio = img.width / img.height; const newWidth = 250, newHeight = newWidth / aspectRatio;
                        items.push({ id: Date.now() + index, type: 'image', img: img, x: worldPos.x - (newWidth / 2) + (index * 20), y: worldPos.y - (newHeight / 2) + (index * 20), width: newWidth, height: newHeight, rotation: 0, isPinned: false });
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        function editText(item) {
            currentlyEditingText = item;
            item.isHidden = true; // Hide canvas version
            const screenPos = worldToScreen({ x: item.x, y: item.y });
            const screenWidth = item.width * cameraZoom, screenHeight = item.height * cameraZoom;
            Object.assign(textEditor.style, {
                display: 'block', left: `${screenPos.x}px`, top: `${screenPos.y}px`,
                width: `${screenWidth}px`, height: `${screenHeight}px`,
                transform: `rotate(${item.rotation}rad)`, transformOrigin: 'top left',
                color: accentColor, backgroundColor: hexToRgba(accentColor, 0.1),
                fontSize: `${item.fontSize * cameraZoom}px`,
            });
            textEditor.value = item.text === "Type..." ? "" : item.text;
            textEditor.focus();
            selectedItems = [];
            updateToolbarPosition();
        }

        function finishEditingText() {
            if (currentlyEditingText) {
                currentlyEditingText.text = textEditor.value || "Type...";
                currentlyEditingText.isHidden = false; // Show canvas version again
                selectedItems = [currentlyEditingText];
                currentlyEditingText = null;
            }
            textEditor.style.display = 'none';
        }

        function saveAsPng() {
            if (items.length === 0) return;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            items.forEach(item => {
                const box = getItemBoundingBox(item);
                minX = Math.min(minX, box.x); minY = Math.min(minY, box.y);
                maxX = Math.max(maxX, box.x + box.width); maxY = Math.max(maxY, box.y + box.height);
            });
            const padding = 50;
            const exportWidth = maxX - minX + padding * 2, exportHeight = maxY - minY + padding * 2;
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = exportWidth; exportCanvas.height = exportHeight;
            const exportCtx = exportCanvas.getContext('2d');
            exportCtx.fillStyle = canvasBackgroundColor;
            exportCtx.fillRect(0, 0, exportWidth, exportHeight);
            exportCtx.translate(-minX + padding, -minY + padding);
            items.forEach(item => {
                exportCtx.save();
                if (showDropShadow) { exportCtx.shadowColor = 'rgba(0,0,0,0.4)'; exportCtx.shadowBlur = 15; exportCtx.shadowOffsetX = 4; exportCtx.shadowOffsetY = 4; }
                if (item.type === 'image') {
                    const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
                    exportCtx.translate(centerX, centerY); exportCtx.rotate(item.rotation); exportCtx.translate(-centerX, -centerY);
                    exportCtx.drawImage(item.img, item.x, item.y, item.width, item.height);
                } else if (item.type === 'arrow') {
                    drawArrow(exportCtx, item);
                } else if (item.type === 'text') {
                    drawTextItem(exportCtx, item);
                } else if (item.type === 'box') {
                    drawBoxItem(exportCtx, item);
                }
                exportCtx.restore();
            });
            const link = document.createElement('a');
            link.download = 'moodboard.png';
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        }

        function getItemBoundingBox(item) {
            if (item.type === 'arrow') {
                return { x: Math.min(item.startX, item.endX), y: Math.min(item.startY, item.endY), width: Math.abs(item.startX - item.endX), height: Math.abs(item.startY - item.endY) };
            }
            const w = item.width, h = item.height, cx = item.x + w / 2, cy = item.y + h / 2, angle = item.rotation;
            const cos = Math.cos(angle), sin = Math.sin(angle);
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            [{x:-w/2,y:-h/2},{x:w/2,y:-h/2},{x:w/2,y:h/2},{x:-w/2,y:h/2}].forEach(c => {
                const rotX = c.x * cos - c.y * sin + cx, rotY = c.x * sin + c.y * cos + cy;
                minX = Math.min(minX, rotX); minY = Math.min(minY, rotY);
                maxX = Math.max(maxX, rotX); maxY = Math.max(maxY, rotY);
            });
            return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
        }
        function rectsIntersect(r1, r2) { return !(r2.x > r1.x + r1.width || r2.x + r2.width < r1.x || r2.y > r1.y + r1.height || r2.y + r2.height < r1.y); }
        function getNormalizedSelectionBox() { return { x: Math.min(selectionBox.startX, selectionBox.endX), y: Math.min(selectionBox.startY, selectionBox.endY), width: Math.abs(selectionBox.startX - selectionBox.endX), height: Math.abs(selectionBox.startY - selectionBox.endY) }; }
        function hexToRgba(hex, alpha) {
            let r=0,g=0,b=0;
            if(hex.length==4){r="0x"+hex[1]+hex[1];g="0x"+hex[2]+hex[2];b="0x"+hex[3]+hex[3];}else if(hex.length==7){r="0x"+hex[1]+hex[2];g="0x"+hex[3]+hex[4];b="0x"+hex[5]+hex[6];}
            return`rgba(${+r},${+g},${+b},${alpha})`;
        }
        function distSq(p1,p2){return Math.pow(p1.x-p2.x,2)+Math.pow(p1.y-p2.y,2);}
        function distToSegmentSquared(p,v,w){
            const l2=distSq(v,w); if(l2===0)return distSq(p,v);
            let t=((p.x-v.x)*(w.x-v.x)+(p.y-v.y)*(w.y-v.y))/l2;
            t=Math.max(0,Math.min(1,t));
            return distSq(p,{x:v.x+t*(w.x-v.x),y:v.y+t*(w.y-v.y)});
        }
        function invertColor(hex){
            if(hex.indexOf('#')===0)hex=hex.slice(1); if(hex.length===3)hex=hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
            if(hex.length!==6)return'#ffffff';
            const r=(255-parseInt(hex.slice(0,2),16)).toString(16),g=(255-parseInt(hex.slice(2,4),16)).toString(16),b=(255-parseInt(hex.slice(4,6),16)).toString(16);
            return'#'+padZero(r)+padZero(g)+padZero(b);
        }
        function hslToRgb(h,s,l){
            let c=(1-Math.abs(2*l-1))*s,x=c*(1-Math.abs((h/60)%2-1)),m=l-c/2,r=0,g=0,b=0;
            if(0<=h&&h<60){r=c;g=x;b=0;}else if(60<=h&&h<120){r=x;g=c;b=0;}else if(120<=h&&h<180){r=0;g=c;b=x;}else if(180<=h&&h<240){r=0;g=x;b=c;}else if(240<=h&&h<300){r=x;g=0;b=c;}else if(300<=h&&h<360){r=c;g=0;b=x;}
            return[Math.round((r+m)*255),Math.round((g+m)*255),Math.round((b+m)*255)];
        }
        function hexToHsl(H){
            let r=0,g=0,b=0;
            if(H.length==4){r="0x"+H[1]+H[1];g="0x"+H[2]+H[2];b="0x"+H[3]+H[3];}else if(H.length==7){r="0x"+H[1]+H[2];g="0x"+H[3]+H[4];b="0x"+H[5]+H[6];}
            r/=255;g/=255;b/=255;
            let cmin=Math.min(r,g,b),cmax=Math.max(r,g,b),delta=cmax-cmin,h=0,s=0,l=0;
            if(delta==0)h=0;else if(cmax==r)h=((g-b)/delta)%6;else if(cmax==g)h=(b-r)/delta+2;else h=(r-g)/delta+4;
            h=Math.round(h*60);if(h<0)h+=360;
            l=(cmax+cmin)/2;s=delta==0?0:delta/(1-Math.abs(2*l-1));
            return[h,s,l];
        }
        function hslToHex(h,s,l){
            let c=(1-Math.abs(2*l-1))*s,x=c*(1-Math.abs((h/60)%2-1)),m=l-c/2,r=0,g=0,b=0;
            if(0<=h&&h<60){r=c;g=x;b=0;}else if(60<=h&&h<120){r=x;g=c;b=0;}else if(120<=h&&h<180){r=0;g=c;b=x;}else if(180<=h&&h<240){r=0;g=x;b=c;}else if(240<=h&&h<300){r=x;g=0;b=c;}else if(300<=h&&h<360){r=c;g=0;b=x;}
            r=Math.round((r+m)*255).toString(16);g=Math.round((g+m)*255).toString(16);b=Math.round((b+m)*255).toString(16);
            if(r.length==1)r="0"+r;if(g.length==1)g="0"+g;if(b.length==1)b="0"+b;
            return"#"+r+g+b;
        }
        function padZero(str,len){len=len||2;const zeros=new Array(len+1).join('0');return(zeros+str).slice(-len);}
        function adjustZoom(e,z){
            if(isDragging)return;
            const wpb=screenToWorld(getEventLocation(e));
            if(z)cameraZoom+=z;
            cameraZoom=Math.min(cameraZoom,MAX_ZOOM);cameraZoom=Math.max(cameraZoom,MIN_ZOOM);
            const wpa=screenToWorld(getEventLocation(e));
            cameraOffset.x+=wpa.x-wpb.x;cameraOffset.y+=wpa.y-wpb.y;
        }
        function gameLoop(){draw();updateToolbarPosition();requestAnimationFrame(gameLoop);}
        resizeCanvas();
        setupEventListeners();
        canvas.style.backgroundColor=canvasBackgroundColor;
        updateUIColors();
        gameLoop();
    </script>
</body>
</html>

