<!DOCTYPE html>
<html lang="en" style="--bg-page: #0d0d0d; --bg-ui: rgba(214, 229, 245, 0.5); --bg-ui-hover: rgba(173, 203, 235, 0.65); --text-color: #0f172a; --text-color-light: #334155; --text-color-strong: #0f172a; --border-color: #99bee5; --switch-bg-checked: #429eff;">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moodinfinite v0.3</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* CSS variables will be set dynamically by JavaScript */
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: var(--bg-page);
            margin: 0;
        }
        canvas {
            display: block;
            background-color: var(--bg-canvas);
            cursor: grab;
        }
        canvas.grabbing {
            cursor: grabbing;
        }
        #context-menu {
            position: absolute;
            z-index: 2100;
            background-color: var(--bg-ui);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            padding: 0.75rem;
            display: none;
            width: 240px;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .menu-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.4rem 0.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .menu-item .text-red-500 {
            color: #ef4444;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        .menu-item:hover {
            background-color: var(--bg-ui-hover);
        }
        .menu-label {
            font-size: 0.875rem;
            color: var(--text-color);
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 38px;
            height: 22px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-color);
            transition: .4s;
            border-radius: 22px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input:checked + .slider {
            background-color: var(--switch-bg-checked);
        }
        input:checked + .slider:before {
            transform: translateX(16px);
        }
        .tool-button {
            background-color: var(--bg-ui);
            border: 1px solid var(--border-color);
            border-radius: 0.375rem;
            padding: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            color: var(--text-color);
        }
        .tool-button:hover {
            background-color: var(--bg-ui-hover);
        }
        .tool-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background-color: var(--bg-ui);
        }
        .tool-button.active {
            background-color: var(--bg-ui-hover);
            border-color: var(--switch-bg-checked);
            color: var(--switch-bg-checked);
        }
        #left-bar {
            position: absolute;
            top: 50%;
            left: 1rem;
            transform: translateY(-50%);
            z-index: 50;
            background-color: var(--bg-ui);
            padding: 0.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            border: 1px solid var(--border-color);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .slider-input {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            flex-grow: 1;
            height: 8px;
            background: var(--border-color);
            border-radius: 9999px;
            cursor: pointer;
        }
        .slider-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 1rem;
            height: 1rem;
            background: var(--switch-bg-checked);
            cursor: pointer;
            border-radius: 50%;
        }
        .slider-value-box {
            background-color: var(--bg-ui-hover);
            color: var(--text-color);
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            min-width: 50px;
            text-align: center;
        }
        .color-picker-input {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 2rem;
            height: 2rem;
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            border-radius: 0.375rem;
            overflow: hidden;
        }
        .color-picker-input::-webkit-color-swatch {
            border-radius: 0.375rem;
            border: 1px solid var(--border-color);
        }
        .color-picker-input::-moz-color-swatch {
            border-radius: 0.375rem;
            border: 1px solid var(--border-color);
        }
        
        #instructions-footer {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            z-index: 50;
            display: flex;
            align-items: center;
            color: var(--text-color-light);
            background-color: var(--bg-ui);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            transition: background-color 0.3s ease-in-out;
            pointer-events: auto;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            padding: 0;
            overflow: hidden;
        }
        #instructions-footer:hover {
            background-color: var(--bg-ui-hover);
        }
        #toggle-help-btn {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            color: var(--text-color-light);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        #toggle-help-btn .chevron {
            transition: transform 0.4s ease-out;
        }
        #help-text {
            padding: 0.5rem 0.75rem 0.5rem 0;
            font-size: 0.75rem;
            white-space: nowrap;
            overflow: hidden;
            transition: max-width 0.4s ease-out, padding 0.4s ease-out, opacity 0.4s 0.1s ease-out;
            max-width: 800px;
        }
        #instructions-footer.closed #help-text {
            max-width: 0;
            padding: 0;
            opacity: 0;
            transition: max-width 0.4s ease-out, padding 0.4s ease-out, opacity 0.2s ease-out;
        }
        #instructions-footer.closed #toggle-help-btn .chevron {
            transform: rotate(180deg);
        }


        #selection-toolbar {
            position: absolute;
            z-index: 1001;
            background-color: var(--bg-ui);
            padding: 0.35rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            display: none;
            gap: 0.35rem;
            border: 1px solid var(--border-color);
            transform: translate(-50%, 10px); /* Position adjustment */
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .selection-tool-btn {
            background-color: transparent;
            border: none;
            border-radius: 0.375rem;
            padding: 0.4rem;
            cursor: pointer;
            color: var(--text-color);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .selection-tool-btn:hover {
            background-color: var(--bg-ui-hover);
        }
        .selection-tool-btn.active {
            background-color: var(--bg-ui-hover);
            color: var(--switch-bg-checked);
        }
        .selection-tool-btn.pinned {
            color: #f59e0b; /* Amber color for pinned */
        }
        .selection-tool-btn .text-red-500 {
             color: #ef4444;
        }
        #save-container {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            z-index: 50;
            display: flex;
            gap: 0.5rem;
        }
        #text-editor {
            position: absolute;
            z-index: 1002;
            border: none;
            outline: none;
            padding: 10px;
            margin: 0;
            font-family: 'Inter', sans-serif;
            font-weight: bold;
            resize: none;
            overflow: hidden;
            box-sizing: border-box;
            line-height: 1.4;
            text-align: center;
        }
        #box-color-picker-container {
            position: absolute;
            z-index: 1001;
            display: none;
        }
        #box-color-picker {
             width: 24px;
             height: 24px;
             padding: 2px;
             border-radius: 50%;
             background-color: var(--bg-ui);
             border: 1px solid var(--border-color);
             box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
         .flex { display: flex; }
        .items-center { align-items: center; }
        .gap-2 { gap: 0.5rem; }
        .border-t { border-top-width: 1px; }
        .my-2 { margin-top: 0.5rem; margin-bottom: 0.5rem; }

        /* Confirmation Modal Styles */
        #confirmation-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 2000;
            display: none; /* Initially hidden */
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }
        #confirmation-modal {
            background-color: var(--bg-ui);
            color: var(--text-color);
            padding: 1.5rem 2rem;
            border-radius: 0.75rem;
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            text-align: center;
        }
        #confirmation-modal h2 {
            margin: 0 0 0.5rem 0;
            font-size: 1.125rem;
        }
        #confirmation-modal p {
            margin: 0 0 1.5rem 0;
            font-size: 0.875rem;
            color: var(--text-color-light);
            max-width: 280px;
        }
        .modal-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
        }
        .modal-button {
            padding: 0.5rem 1rem;
            border: 1px solid transparent;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .modal-button.confirm {
            background-color: #ef4444; /* Red */
            color: white;
            border-color: #dc2626;
        }
        .modal-button.confirm:hover {
            background-color: #dc2626;
        }
        .modal-button.cancel {
            background-color: var(--bg-ui-hover);
            color: var(--text-color);
            border-color: var(--border-color);
        }
        .modal-button.cancel:hover {
            opacity: 0.8;
        }
    </style>
</head>
<body>

    <canvas id="moodboard-canvas"></canvas>
    
    <!-- File inputs for images and projects -->
    <input type="file" id="image-input" accept="image/png, image/jpeg, image/gif, image/svg+xml, image/webp" style="display: none;" multiple>
    <input type="file" id="project-input" accept=".json, .mood" style="display: none;">
    
    <textarea id="text-editor" style="display: none;"></textarea>

    <!-- Left Toolbar for adding elements -->
    <div id="left-bar">
        <button id="new-file-btn" title="New Board (Shift+N)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line></svg>
        </button>
         <button id="add-image-btn" title="Add Image (I)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 15 9 5 19"></polyline></svg>
        </button>
        <button id="add-text-btn" title="Add Text (T)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg>
        </button>
        <button id="add-arrow-btn" title="Add Arrow (A)" class="tool-button">
           <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>
        </button>
        <button id="add-box-btn" title="Add Box (B)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>
        </button>
        <button id="align-btn" title="Auto Align Selection" class="tool-button" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>
        </button>
    </div>

    <!-- Right-click context menu -->
    <div id="context-menu">
        <div class="menu-item">
            <label class="menu-label">Colors</label>
            <div class="flex items-center gap-2">
                <input type="color" id="bg-color-picker" class="color-picker-input" value="#0d0d0d" title="Background Color">
                <input type="color" id="accent-color-picker" class="color-picker-input" value="#429eff" title="Accent Color">
                <input type="color" id="grid-color-picker" class="color-picker-input" value="#f9f8f6" title="Grid Color">
            </div>
        </div>
        <div class="menu-item">
            <label for="drop-shadow-toggle" class="menu-label">Drop Shadow</label>
            <label class="switch">
                <input type="checkbox" id="drop-shadow-toggle" checked>
                <span class="slider"></span>
            </label>
        </div>
        <div class="border-t my-2" id="opacity-separator" style="border-color: var(--border-color); display: none;"></div>
        <div class="menu-item" id="opacity-slider-container" style="display: none;">
            <label for="item-opacity-slider" class="menu-label">Opacity</label>
            <div class="flex items-center gap-2" style="width: 60%;">
                <input type="range" id="item-opacity-slider" min="0.05" max="1" step="0.05" value="1" class="slider-input">
                <div id="item-opacity-value" class="slider-value-box">100%</div>
            </div>
        </div>
        <div class="border-t my-2" style="border-color: var(--border-color);"></div>
        <div class="menu-item">
            <label for="show-grid-toggle" class="menu-label">Show Grid</label>
            <label class="switch">
                <input type="checkbox" id="show-grid-toggle" checked>
                <span class="slider"></span>
            </label>
        </div>
        <div class="menu-item">
            <label for="snap-grid-toggle" class="menu-label">Snap to Grid</label>
            <label class="switch">
                <input type="checkbox" id="snap-grid-toggle" checked>
                <span class="slider"></span>
            </label>
        </div>
        <div class="menu-item">
            <label for="grid-opacity-slider" class="menu-label">Grid Opacity</label>
            <div class="flex items-center gap-2" style="width: 60%;">
                <input type="range" id="grid-opacity-slider" min="0" max="1" step="0.05" value="0.05" class="slider-input">
                <div id="grid-opacity-value" class="slider-value-box">5%</div>
            </div>
        </div>
        <div class="menu-item">
            <label for="grid-size-slider" class="menu-label">Grid Size</label>
            <div class="flex items-center gap-2" style="width: 60%;">
                <input type="range" id="grid-size-slider" min="10" max="200" value="50" class="slider-input">
                <div id="grid-size-value" class="slider-value-box">50px</div>
            </div>
        </div>
         <div class="border-t my-2" id="delete-separator" style="border-color: var(--border-color);"></div>
         <div class="menu-item" id="delete-item-btn">
             <span class="menu-label text-red-500">Delete Selected</span>
             <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-red-500"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
         </div>
    </div>

    <!-- Footer instructions -->
    <div id="instructions-footer">
        <button id="toggle-help-btn" title="Toggle Help Bar (H)">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="chevron"><polyline points="15 18 9 12 15 6"></polyline></svg>
        </button>
        <span id="help-text">
            Shift+N: New | Ctrl+S: Save | Ctrl+O: Open | Ctrl+Z: Undo | Ctrl+Shift+Z: Redo
        </span>
    </div>

    <!-- Bottom right save buttons -->
    <div id="save-container">
        <button id="load-project-btn" title="Open Project (Ctrl+O)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>
        </button>
        <button id="save-project-btn" title="Save Project (Ctrl+S)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>
        </button>
        <button id="save-png-btn" title="Export as PNG (Shift+S)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
        </button>
    </div>
    
    <div id="box-color-picker-container">
        <input type="color" id="box-color-picker" class="color-picker-input">
    </div>

    <!-- Floating toolbar for selected items -->
    <div id="selection-toolbar">
         <button id="toggle-box-style-btn" class="selection-tool-btn" title="Toggle Box Style">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>
        </button>
        <button id="bring-front-btn" class="selection-tool-btn" title="Bring to Front (Page Up)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3v18h18"/><path d="M21 21V8a2 2 0 0 0-2-2H8a2 2 0 0 0-2 2v13"/></svg>
        </button>
        <button id="send-back-btn" class="selection-tool-btn" title="Send to Back (Page Down)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V4a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-1"/><path d="M8 22v-4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v4"/></svg>
        </button>
        <button id="scale-btn" class="selection-tool-btn" title="Scale (S)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 21l-6-6m6 6v-4m0 4h-4"></path><path d="M3 3l6 6m-6-6v4m0-4h4"></path></svg>
        </button>
        <button id="rotate-btn" class="selection-tool-btn" title="Rotate (R)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
        </button>
        <button id="pin-btn" class="selection-tool-btn" title="Pin (P)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.05A5 5 0 0 1 18 19.05M16 13l-6 6-4-4-6-6"></path></svg>
        </button>
        <button id="delete-selection-btn" class="selection-tool-btn" title="Delete (Del)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-red-500"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
        </button>
    </div>

    <!-- Confirmation Modal for New Board -->
    <div id="confirmation-modal-overlay">
        <div id="confirmation-modal">
            <h2>Create New Board?</h2>
            <p>All unsaved changes will be lost. Are you sure you want to continue?</p>
            <div class="modal-buttons">
                <button id="cancel-new-btn" class="modal-button cancel">Cancel</button>
                <button id="confirm-new-btn" class="modal-button confirm">Yes, Clear Board</button>
            </div>
        </div>
    </div>


    <script>
        // Canvas and DOM Elements
        const canvas = document.getElementById('moodboard-canvas');
        const ctx = canvas.getContext('2d');
        const imageInput = document.getElementById('image-input');
        const projectInput = document.getElementById('project-input');
        const newFileBtn = document.getElementById('new-file-btn');
        const addImageBtn = document.getElementById('add-image-btn');
        const addTextBtn = document.getElementById('add-text-btn');
        const addArrowBtn = document.getElementById('add-arrow-btn');
        const addBoxBtn = document.getElementById('add-box-btn');
        const alignBtn = document.getElementById('align-btn');
        const contextMenu = document.getElementById('context-menu');
        const showGridToggle = document.getElementById('show-grid-toggle');
        const snapGridToggle = document.getElementById('snap-grid-toggle');
        const dropShadowToggle = document.getElementById('drop-shadow-toggle');
        const gridSizeSlider = document.getElementById('grid-size-slider');
        const gridSizeValue = document.getElementById('grid-size-value');
        const gridOpacitySlider = document.getElementById('grid-opacity-slider');
        const gridOpacityValue = document.getElementById('grid-opacity-value');
        const deleteItemBtn = document.getElementById('delete-item-btn');
        const savePngBtn = document.getElementById('save-png-btn');
        const saveProjectBtn = document.getElementById('save-project-btn');
        const loadProjectBtn = document.getElementById('load-project-btn');
        const bgColorPicker = document.getElementById('bg-color-picker');
        const accentColorPicker = document.getElementById('accent-color-picker');
        const gridColorPicker = document.getElementById('grid-color-picker');
        const textEditor = document.getElementById('text-editor');
        const boxColorPickerContainer = document.getElementById('box-color-picker-container');
        const boxColorPicker = document.getElementById('box-color-picker');
        const selectionToolbar = document.getElementById('selection-toolbar');
        const toggleBoxStyleBtn = document.getElementById('toggle-box-style-btn');
        const scaleBtn = document.getElementById('scale-btn');
        const rotateBtn = document.getElementById('rotate-btn');
        const pinBtn = document.getElementById('pin-btn');
        const deleteSelectionBtn = document.getElementById('delete-selection-btn');
        const bringFrontBtn = document.getElementById('bring-front-btn');
        const sendBackBtn = document.getElementById('send-back-btn');
        const confirmationModalOverlay = document.getElementById('confirmation-modal-overlay');
        const confirmNewBtn = document.getElementById('confirm-new-btn');
        const cancelNewBtn = document.getElementById('cancel-new-btn');
        const instructionsFooter = document.getElementById('instructions-footer');
        const toggleHelpBtn = document.getElementById('toggle-help-btn');
        const opacitySliderContainer = document.getElementById('opacity-slider-container');
        const opacitySeparator = document.getElementById('opacity-separator');
        const itemOpacitySlider = document.getElementById('item-opacity-slider');
        const itemOpacityValue = document.getElementById('item-opacity-value');

        // State Variables
        let isHelpOpen = true;
        let cameraOffset = { x: 0, y: 0 };
        let cameraZoom = 1;
        const MAX_ZOOM = 5, MIN_ZOOM = 0.1, SCROLL_SENSITIVITY = 0.0005;
        let isDragging = false, dragStart = { x: 0, y: 0 };
        let items = [], selectedItems = []; 
        let isMovingItems = false, moveStart = {x: 0, y: 0};
        let currentTool = null, isDrawing = false;
        let canvasBackgroundColor = '#0d0d0d', accentColor = '#429eff', gridColor = '#f9f8f6';
        let activeGizmo = null, isTransforming = false, isTransformingArrow = false;
        let transformingHandle = null, transformStart = { x: 0, y: 0 }, originalItemState = null;
        let hoveredGizmo = null, hoveredArrowHandle = null;
        let isSelectingBox = false, selectionBox = { startX: 0, startY: 0, endX: 0, endY: 0 };
        let currentlyEditingText = null;
        let showGrid = true, snapToGrid = true, showDropShadow = true;
        let gridSize = 50, gridOpacity = 0.05;
        let currentProjectName = 'moodboard';

        // History/Undo State
        let historyStack = [];
        let historyIndex = -1;
        const HISTORY_LIMIT = 50;

        // --- CORE FUNCTIONS ---

        function setupEventListeners() {
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('dblclick', onDoubleClick);
            canvas.addEventListener('wheel', (e) => { e.preventDefault(); adjustZoom(e, -e.deltaY * SCROLL_SENSITIVITY); });
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', handleKeyDown);
            canvas.addEventListener('contextmenu', onContextMenu);
            document.addEventListener('click', (e) => { if (!contextMenu.contains(e.target)) contextMenu.style.display = 'none'; });
            
            // Drag and drop listeners for images and projects
            window.addEventListener('paste', handlePaste);
            canvas.addEventListener('dragover', handleDragOver);
            canvas.addEventListener('dragleave', handleDragLeave);
            canvas.addEventListener('drop', handleDrop);

            // Button listeners
            toggleHelpBtn.addEventListener('click', toggleHelpFooter);
            newFileBtn.addEventListener('click', confirmNewBoard);
            savePngBtn.addEventListener('click', saveAsPng);
            saveProjectBtn.addEventListener('click', saveProject);
            loadProjectBtn.addEventListener('click', () => projectInput.click());
            addImageBtn.addEventListener('click', () => imageInput.click());
            imageInput.addEventListener('change', handleImageUpload);
            projectInput.addEventListener('change', handleProjectUpload);
            addArrowBtn.addEventListener('click', () => setCurrentTool('arrow'));
            addTextBtn.addEventListener('click', () => setCurrentTool('text'));
            addBoxBtn.addEventListener('click', () => setCurrentTool('box'));
            alignBtn.addEventListener('click', autoAlignSelection);
            
            // Context Menu listeners
            showGridToggle.addEventListener('change', (e) => showGrid = e.target.checked);
            snapGridToggle.addEventListener('change', (e) => snapToGrid = e.target.checked);
            dropShadowToggle.addEventListener('change', (e) => showDropShadow = e.target.checked);
            gridSizeSlider.addEventListener('input', (e) => { gridSize = parseInt(e.target.value); gridSizeValue.textContent = `${gridSize}px`; });
            gridOpacitySlider.addEventListener('input', (e) => { gridOpacity = parseFloat(e.target.value); gridOpacityValue.textContent = `${Math.round(gridOpacity * 100)}%`; });
            deleteItemBtn.addEventListener('click', deleteSelectedItems);
            bgColorPicker.addEventListener('input', e => { canvasBackgroundColor = e.target.value; canvas.style.backgroundColor = canvasBackgroundColor; updateUIColors(); });
            accentColorPicker.addEventListener('input', e => { accentColor = e.target.value; updateUIColors(); });
            gridColorPicker.addEventListener('input', e => { gridColor = e.target.value; });
            itemOpacitySlider.addEventListener('input', (e) => {
                const newOpacity = parseFloat(e.target.value);
                selectedItems.forEach(item => {
                    item.opacity = newOpacity;
                });
                itemOpacityValue.textContent = `${Math.round(newOpacity * 100)}%`;
            });
            itemOpacitySlider.addEventListener('change', () => {
                saveStateForUndo();
            });

            // Selection Toolbar listeners
            toggleBoxStyleBtn.addEventListener('click', toggleBoxStyle);
            scaleBtn.addEventListener('click', () => setActiveGizmo('scale'));
            rotateBtn.addEventListener('click', () => setActiveGizmo('rotate'));
            pinBtn.addEventListener('click', togglePin);
            deleteSelectionBtn.addEventListener('click', deleteSelectedItems);
            bringFrontBtn.addEventListener('click', bringSelectedToFront);
            sendBackBtn.addEventListener('click', sendSelectedToBack);

            // Text and color picker listeners
            textEditor.addEventListener('blur', finishEditingText);
            textEditor.addEventListener('input', autoResizeTextEditor);
            textEditor.addEventListener('keydown', (e) => { if (e.key === 'Escape') finishEditingText(); });
            boxColorPicker.addEventListener('input', (e) => {
                if(selectedItems.length === 1 && selectedItems[0].type === 'box'){
                    selectedItems[0].color = e.target.value;
                }
            });

            // Confirmation Modal Listeners
            confirmNewBtn.addEventListener('click', () => { 
                resetBoard();
                hideConfirmationModal(); 
            });
            cancelNewBtn.addEventListener('click', hideConfirmationModal);
        }
        
        function resizeCanvas() { 
            cameraOffset.x += (window.innerWidth - canvas.width) / 2;
            cameraOffset.y += (window.innerHeight - canvas.height) / 2;
            canvas.width = window.innerWidth; 
            canvas.height = window.innerHeight; 
        }

        // Main animation loop
        function gameLoop(){
            draw();
            updateToolbarPosition();
            requestAnimationFrame(gameLoop);
        }

        // --- DRAWING FUNCTIONS ---

        function draw() {
            // Reset canvas and apply camera transforms
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(cameraZoom, cameraZoom);
            ctx.translate(-canvas.width / 2 + cameraOffset.x, -canvas.height / 2 + cameraOffset.y);
            
            if (showGrid) drawGrid();
            
            // Draw all items
            items.forEach(item => {
                if(item.isHidden) return;
                ctx.save();
                ctx.globalAlpha = item.opacity ?? 1;
                if (showDropShadow) {
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                    ctx.shadowBlur = 15 / cameraZoom;
                    ctx.shadowOffsetX = 4 / cameraZoom;
                    ctx.shadowOffsetY = 4 / cameraZoom;
                }
                if(item.type === 'image') {
                    const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
                    ctx.translate(centerX, centerY);
                    ctx.rotate(item.rotation);
                    ctx.translate(-centerX, -centerY);
                    if (item.img.complete) {
                        ctx.drawImage(item.img, item.x, item.y, item.width, item.height);
                    }
                } else if (item.type === 'arrow') {
                    drawArrow(ctx, item);
                } else if (item.type === 'text') {
                    drawTextItem(ctx, item);
                } else if (item.type === 'box') {
                    drawBoxItem(ctx, item);
                }
                ctx.restore();

                // Draw selection outline after restoring context to avoid shadow on it
                if (selectedItems.includes(item)) drawSelection(item);
            });
            
            if(isSelectingBox) drawSelectionBox();
            ctx.restore();
        }

        function drawSelection(item) {
            // For multiple selections, just draw a simple outline
            if (selectedItems.length > 1) { 
                drawSelectionOutline(item); 
                return; 
            }
            
            // For a single selected arrow, draw its handles
            if (item.type === 'arrow' && !item.isPinned) {
                 const handleSize = 8 / cameraZoom, gizmoColor = invertColor(canvasBackgroundColor);
                ctx.save();
                ctx.fillStyle = gizmoColor;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 4 / cameraZoom;
                ctx.beginPath();
                ctx.arc(item.startX, item.startY, handleSize, 0, Math.PI * 2);
                ctx.fill();
                if (hoveredArrowHandle === 'start') { ctx.strokeStyle = accentColor; ctx.lineWidth = 2 / cameraZoom; ctx.stroke(); }
                ctx.beginPath();
                ctx.arc(item.endX, item.endY, handleSize, 0, Math.PI * 2);
                ctx.fill();
                if (hoveredArrowHandle === 'end') { ctx.strokeStyle = accentColor; ctx.lineWidth = 2 / cameraZoom; ctx.stroke(); }
                ctx.restore();
                return; 
            }

            // For other single selected items, draw outline and gizmos
            ctx.save();
            const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
            ctx.translate(centerX, centerY);
            ctx.rotate(item.rotation);
            ctx.strokeStyle = accentColor;
            ctx.lineWidth = 2 / cameraZoom;
            ctx.strokeRect(-item.width / 2, -item.height / 2, item.width, item.height);
            if (activeGizmo && !item.isPinned) {
                const gizmoColor = invertColor(canvasBackgroundColor), handleSize = 8 / cameraZoom;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 4 / cameraZoom;
                ctx.fillStyle = gizmoColor;
                ctx.strokeStyle = gizmoColor;
                if (activeGizmo === 'scale') {
                    const cornerX = item.width / 2, cornerY = item.height / 2;
                    ctx.beginPath();
                    ctx.arc(cornerX, cornerY, handleSize, 0, Math.PI * 2);
                    ctx.fill();
                    if (hoveredGizmo === 'scale') { ctx.strokeStyle = accentColor; ctx.lineWidth = 2 / cameraZoom; ctx.stroke(); }
                } else if (activeGizmo === 'rotate') {
                    const cornerX = item.width / 2, cornerY = -item.height / 2;
                    const handleY = cornerY - 20 / cameraZoom;
                    ctx.beginPath();
                    ctx.moveTo(cornerX, cornerY);
                    ctx.lineTo(cornerX, handleY);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(cornerX, handleY, handleSize, 0, Math.PI * 2);
                    ctx.fill();
                    if (hoveredGizmo === 'rotate') { ctx.strokeStyle = accentColor; ctx.lineWidth = 2 / cameraZoom; ctx.stroke(); }
                }
            }
            ctx.restore();
        }

        function drawSelectionOutline(item) {
            ctx.save();
            const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
            ctx.translate(centerX, centerY);
            ctx.rotate(item.rotation);
            ctx.strokeStyle = accentColor;
            ctx.lineWidth = 2 / cameraZoom;
            ctx.setLineDash([6 / cameraZoom, 4 / cameraZoom]);
            ctx.strokeRect(-item.width / 2, -item.height / 2, item.width, item.height);
            ctx.restore();
        }

        function drawSelectionBox() {
            ctx.save();
            ctx.fillStyle = hexToRgba(accentColor, 0.1);
            ctx.strokeStyle = accentColor;
            ctx.lineWidth = 1 / cameraZoom;
            const { x, y, width, height } = getNormalizedSelectionBox();
            ctx.fillRect(x, y, width, height);
            ctx.strokeRect(x, y, width, height);
            ctx.restore();
        }

        function drawGrid() {
            const worldLeft = (0 - canvas.width / 2) / cameraZoom - cameraOffset.x + canvas.width / 2;
            const worldTop = (0 - canvas.height / 2) / cameraZoom - cameraOffset.y + canvas.height / 2;
            const worldRight = (canvas.width - canvas.width / 2) / cameraZoom - cameraOffset.x + canvas.width / 2;
            const worldBottom = (canvas.height - canvas.height / 2) / cameraZoom - cameraOffset.y + canvas.height / 2;
            const startX = Math.floor(worldLeft / gridSize) * gridSize;
            const startY = Math.floor(worldTop / gridSize) * gridSize;
            ctx.save();
            ctx.globalAlpha = gridOpacity;
            ctx.beginPath();
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1 / cameraZoom;
            for (let x = startX; x < worldRight; x += gridSize) { ctx.moveTo(x, worldTop); ctx.lineTo(x, worldBottom); }
            for (let y = startY; y < worldBottom; y += gridSize) { ctx.moveTo(worldLeft, y); ctx.lineTo(worldRight, y); }
            ctx.stroke();
            ctx.restore();
        }
        
        function drawArrow(context, arrow) {
            const headlen = 10 / cameraZoom;
            const dx = arrow.endX - arrow.startX, dy = arrow.endY - arrow.startY;
            const angle = Math.atan2(dy, dx);
            context.save();
            context.beginPath();
            context.moveTo(arrow.startX, arrow.startY);
            context.lineTo(arrow.endX, arrow.endY);
            context.lineTo(arrow.endX - headlen * Math.cos(angle - Math.PI / 6), arrow.endY - headlen * Math.sin(angle - Math.PI / 6));
            context.moveTo(arrow.endX, arrow.endY);
            context.lineTo(arrow.endX - headlen * Math.cos(angle + Math.PI / 6), arrow.endY - headlen * Math.sin(angle + Math.PI / 6));
            context.strokeStyle = accentColor;
            context.lineWidth = 3 / cameraZoom;
            context.stroke();
            context.restore();
        }

        function drawTextItem(context, item) {
            context.save();
            const centerX = item.x + item.width / 2;
            const centerY = item.y + item.height / 2;
            context.translate(centerX, centerY);
            context.rotate(item.rotation);

            // Draw background
            context.globalAlpha = (item.opacity ?? 1) * 0.05;
            context.fillStyle = accentColor;
            context.fillRect(-item.width / 2, -item.height / 2, item.width, item.height);
            context.globalAlpha = item.opacity ?? 1;

            // Prepare text
            context.fillStyle = accentColor;
            context.font = `bold ${item.fontSize}px 'Inter', sans-serif`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';

            const words = item.text.split(' ');
            const lines = [];
            let currentLine = '';
            const padding = 10;
            const maxWidth = item.width - padding * 2;
            
            for (let i = 0; i < words.length; i++) {
                const testLine = currentLine + words[i] + ' ';
                if (context.measureText(testLine).width > maxWidth && i > 0) {
                    lines.push(currentLine.trim());
                    currentLine = words[i] + ' ';
                } else {
                    currentLine = testLine;
                }
            }
            lines.push(currentLine.trim());

            const lineHeight = item.fontSize * 1.4;
            const totalTextHeight = lines.length * lineHeight;
            let startY = -totalTextHeight / 2 + lineHeight / 2;

            lines.forEach((line, index) => {
                context.fillText(line, 0, startY + index * lineHeight);
            });
            
            context.restore();
        }

        function drawBoxItem(context, item) {
            context.save();
            const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
            context.translate(centerX, centerY);
            context.rotate(item.rotation);
            
            if (!item.style || item.style === 'fill') {
                context.fillStyle = item.color;
                context.fillRect(-item.width / 2, -item.height / 2, item.width, item.height);
            } else { // 'outline' style
                context.strokeStyle = item.color;
                context.lineWidth = 4 / cameraZoom;
                context.strokeRect(-item.width / 2, -item.height / 2, item.width, item.height);
            }
            
            context.restore();
        }

        // --- EVENT HANDLERS & INPUT ---

        function handleKeyDown(e) {
            const key = e.key.toLowerCase();
            if (currentlyEditingText) return;

            // New, Save, Open, and Undo shortcuts
            if (e.shiftKey && key === 'n') { e.preventDefault(); confirmNewBoard(); return; }
            if (key === 'h') { e.preventDefault(); toggleHelpFooter(); return; }
            
            if (e.ctrlKey) {
                if (e.shiftKey && key === 'z') { e.preventDefault(); redoLastAction(); return; }
                if (key === 's') { e.preventDefault(); saveProject(); return; }
                if (key === 'o') { e.preventDefault(); projectInput.click(); return; }
                if (key === 'z') { e.preventDefault(); undoLastAction(); return; }
                if (key === 'a') { e.preventDefault(); selectedItems = [...items]; updateSelectionToolbar(); updateLeftBarState(); return; }
            }
            if (e.shiftKey && key === 's') { e.preventDefault(); saveAsPng(); return; }
            
            // Tool shortcuts
            if (key === 'g') { e.preventDefault(); showGrid = !showGrid; showGridToggle.checked = showGrid; return; }
            if (key === 'a') { e.preventDefault(); setCurrentTool('arrow'); return; }
            if (key === 't') { e.preventDefault(); setCurrentTool('text'); return; }
            if (key === 'i') { e.preventDefault(); imageInput.click(); return; }
            if (key === 'b') { e.preventDefault(); setCurrentTool('box'); return; }

            if (selectedItems.length === 0) return;

            // Layering shortcuts
            if (key === 'pageup') { e.preventDefault(); bringSelectedToFront(); return; }
            if (key === 'pagedown') { e.preventDefault(); sendSelectedToBack(); return; }
            
            if (key === 'delete' || key === 'backspace') { e.preventDefault(); deleteSelectedItems(); return; }
            
            if(selectedItems.length !== 1) return;
            const selectedItem = selectedItems[0];
            e.preventDefault();
            if (key === 'p') { togglePin(); return; }
            if (selectedItem.isPinned) return;
            switch (key) {
                case 'r': setActiveGizmo('rotate'); break;
                case 's': setActiveGizmo('scale'); break;
            }
        }

        function onDoubleClick(e) {
            const worldPos = screenToWorld(getEventLocation(e));
            const item = getItemAtPosition(worldPos);
            if (item && item.type === 'text' && !item.isPinned) editText(item);
        }

        function onMouseDown(e) {
            if (currentlyEditingText) { finishEditingText(); return; }
            const worldPos = screenToWorld(getEventLocation(e));

            // Left click
            if (e.button === 0) {
                // Check for gizmo/handle interaction first
                if (selectedItems.length === 1) {
                    if (selectedItems[0].type === 'arrow' && !selectedItems[0].isPinned) {
                        const handle = getArrowHandleAtPosition(worldPos);
                        if (handle) { isTransformingArrow = true; transformingHandle = handle; return; }
                    }
                    const gizmo = getGizmoAtPosition(worldPos);
                    if (gizmo && !selectedItems[0].isPinned) {
                        isTransforming = true;
                        originalItemState = { 
                            ...selectedItems[0], 
                            centerX: selectedItems[0].x + selectedItems[0].width / 2, 
                            centerY: selectedItems[0].y + selectedItems[0].height / 2, 
                            startAngle: Math.atan2(worldPos.y - (selectedItems[0].y + selectedItems[0].height / 2), worldPos.x - (selectedItems[0].x + selectedItems[0].width / 2)), 
                            startDist: Math.hypot(worldPos.x - (selectedItems[0].x + selectedItems[0].width / 2), worldPos.y - (selectedItems[0].y + selectedItems[0].height / 2)), 
                        };
                        return;
                    }
                }
                
                // If using a tool, start drawing
                if(currentTool) {
                    isDrawing = true;
                    let newItem;
                    if(currentTool === 'arrow') {
                        newItem = { id: Date.now(), type: 'arrow', startX: worldPos.x, startY: worldPos.y, endX: worldPos.x, endY: worldPos.y, rotation: 0, isPinned: false, x: worldPos.x, y: worldPos.y, width: 0, height: 0, opacity: 1 };
                    } else if (currentTool === 'text') {
                        newItem = { id: Date.now(), type: 'text', text: 'Type...', x: worldPos.x, y: worldPos.y, width: 0, height: 0, fontSize: 32, rotation: 0, isPinned: false, opacity: 1 };
                    } else if (currentTool === 'box') {
                        newItem = { id: Date.now(), type: 'box', color: accentColor, x: worldPos.x, y: worldPos.y, width: 0, height: 0, rotation: 0, isPinned: false, style: 'fill', opacity: 1 };
                    }
                    items.push(newItem);
                    selectedItems = [newItem];
                    bringSelectedToFront(); // New items on top
                } else {
                    const newSelectedItem = getItemAtPosition(worldPos);
                    // Shift-click to add/remove from selection
                    if (e.shiftKey) {
                         if (newSelectedItem) {
                            const index = selectedItems.findIndex(item => item.id === newSelectedItem.id);
                            if (index > -1) selectedItems.splice(index, 1); 
                            else selectedItems.push(newSelectedItem);
                        }
                    } else {
                        // FIX: Unified movement/selection logic
                        if (newSelectedItem) {
                            if (!selectedItems.includes(newSelectedItem)) {
                                selectedItems = [newSelectedItem];
                            }
                            isMovingItems = true;
                            moveStart.x = worldPos.x;
                            moveStart.y = worldPos.y;
                            selectedItems.forEach(item => {
                                item.originalX = item.x; item.originalY = item.y;
                                if(item.type === 'arrow'){ item.originalStartX = item.startX; item.originalStartY = item.startY; item.originalEndX = item.endX; item.originalEndY = item.endY; }
                            });
                        } else {
                            // Clicked on empty space, start selection box
                            selectedItems = [];
                            isSelectingBox = true;
                            selectionBox.startX = worldPos.x; selectionBox.startY = worldPos.y;
                            selectionBox.endX = worldPos.x; selectionBox.endY = worldPos.y;
                        }
                    }
                    updateSelectionToolbar();
                    updateLeftBarState();
                }
            } 
            // Middle click to pan
            else if (e.button === 1) {
                isDragging = true; 
                dragStart.x = getEventLocation(e).x / cameraZoom - cameraOffset.x; 
                dragStart.y = getEventLocation(e).y / cameraZoom - cameraOffset.y; 
                canvas.classList.add('grabbing');
            }
        }

        function onMouseUp(e) {
            if (e.button === 0) {
                // If any action was taken that modifies items, save state for undo
                if (isDrawing || isMovingItems || isTransforming || isTransformingArrow) {
                    if (isDrawing) {
                        const item = selectedItems[0];
                        if (item && (item.type === 'text' || item.type === 'box') && (item.width < 10 || item.height < 10)) {
                             items = items.filter(i => i.id !== item.id);
                             selectedItems = [];
                        } else if (item && item.type === 'text') {
                            editText(item);
                        }
                    }
                    saveStateForUndo();
                }

                // Finalize selection box
                if (isSelectingBox) {
                    isSelectingBox = false;
                    const box = getNormalizedSelectionBox();
                    selectedItems = items.filter(item => rectsIntersect(getItemBoundingBox(item), box));
                    updateSelectionToolbar();
                    updateLeftBarState();
                }

                // Reset states
                isDrawing = false; isMovingItems = false; isTransforming = false; isTransformingArrow = false;
                transformingHandle = null; originalItemState = null;
                setCurrentTool(null);
            } else if (e.button === 1) { 
                isDragging = false; 
                canvas.classList.remove('grabbing'); 
            }
        }

        function onMouseMove(e) {
            const worldPos = screenToWorld(getEventLocation(e));
            
            // Update selection box
            if(isSelectingBox){ selectionBox.endX = worldPos.x; selectionBox.endY = worldPos.y; return; }

            // Handle arrow transformations
            if (isTransformingArrow && selectedItems.length === 1) {
                const selectedItem = selectedItems[0];
                if (transformingHandle === 'start') { selectedItem.startX = worldPos.x; selectedItem.startY = worldPos.y; } 
                else if (transformingHandle === 'end') { selectedItem.endX = worldPos.x; selectedItem.endY = worldPos.y; }
                return;
            }

            // Handle item transformations (scale/rotate)
            if (isTransforming && selectedItems.length === 1) {
                const selectedItem = selectedItems[0];
                const centerX = originalItemState.centerX, centerY = originalItemState.centerY;
                if (activeGizmo === 'rotate') {
                    const currentAngle = Math.atan2(worldPos.y - centerY, worldPos.x - centerX);
                    let newRotation = originalItemState.rotation + (currentAngle - originalItemState.startAngle);
                    if (e.shiftKey) newRotation = Math.round(newRotation / (Math.PI / 12)) * (Math.PI / 12);
                    selectedItem.rotation = newRotation;
                } else if (activeGizmo === 'scale') {
                    const currentDist = Math.hypot(worldPos.x - centerX, worldPos.y - centerY);
                    const scaleFactor = Math.max(0.1, currentDist / originalItemState.startDist);
                    selectedItem.width = originalItemState.width * scaleFactor;
                    selectedItem.height = originalItemState.height * scaleFactor;
                    selectedItem.x = centerX - selectedItem.width / 2;
                    selectedItem.y = centerY - selectedItem.height / 2;
                    if(selectedItem.type === 'text') selectedItem.fontSize = originalItemState.fontSize * scaleFactor;
                }
            } 
            // FIX: Unified item movement
            else if(isMovingItems && selectedItems.length > 0) {
                 const dx = worldPos.x - moveStart.x;
                 const dy = worldPos.y - moveStart.y;
                selectedItems.forEach(item => {
                    if (item.isPinned) return;
                    let newX = item.originalX + dx;
                    let newY = item.originalY + dy;
                    if (snapToGrid && selectedItems.length === 1) {
                        newX = Math.round(newX / gridSize) * gridSize;
                        newY = Math.round(newY / gridSize) * gridSize;
                    }
                    const itemDx = newX - item.x, itemDy = newY - item.y;
                    if (item.type === 'arrow') { 
                        item.startX += itemDx; item.startY += itemDy; 
                        item.endX += itemDx; item.endY += itemDy; 
                    }
                    item.x = newX;
                    item.y = newY;
                });
            } 
            // Handle drawing new items
            else if (isDrawing && selectedItems.length === 1) {
                const selectedItem = selectedItems[0];
                 if(selectedItem.type === 'arrow') {
                    selectedItem.endX = worldPos.x; selectedItem.endY = worldPos.y;
                } else if(selectedItem.type === 'text' || selectedItem.type === 'box') {
                    selectedItem.width = Math.abs(worldPos.x - selectedItem.x);
                    selectedItem.height = Math.abs(worldPos.y - selectedItem.y);
                    selectedItem.x = Math.min(worldPos.x, selectedItem.x);
                    selectedItem.y = Math.min(worldPos.y, selectedItem.y);
                }
            } 
            // Handle camera panning
            else if (isDragging) {
                cameraOffset.x = getEventLocation(e).x / cameraZoom - dragStart.x; 
                cameraOffset.y = getEventLocation(e).y / cameraZoom - dragStart.y;
            }

            // Update cursor style based on context
            if (!isDragging && !isMovingItems && !isTransforming && !isTransformingArrow) {
                const currentHoveredGizmo = getGizmoAtPosition(worldPos);
                const currentHoveredArrowHandle = getArrowHandleAtPosition(worldPos);
                if (currentHoveredGizmo !== hoveredGizmo || currentHoveredArrowHandle !== hoveredArrowHandle) {
                    hoveredGizmo = currentHoveredGizmo;
                    hoveredArrowHandle = currentHoveredArrowHandle;
                }
                if (hoveredGizmo || hoveredArrowHandle) canvas.style.cursor = 'pointer';
                else if (getItemAtPosition(worldPos)) canvas.style.cursor = 'move';
                else if (currentTool) canvas.style.cursor = 'crosshair';
                else canvas.style.cursor = 'grab';
            }
        }
        
        function onContextMenu(e) {
            e.preventDefault();
            const itemUnderCursor = getItemAtPosition(screenToWorld(getEventLocation(e)));
            if (itemUnderCursor && !selectedItems.includes(itemUnderCursor)) {
                selectedItems = [itemUnderCursor]; 
                updateSelectionToolbar();
                updateLeftBarState();
            }

            if (selectedItems.length > 0) {
                opacitySliderContainer.style.display = 'flex';
                opacitySeparator.style.display = 'block';
                const referenceOpacity = selectedItems[0].opacity ?? 1;
                itemOpacitySlider.value = referenceOpacity;
                itemOpacityValue.textContent = `${Math.round(referenceOpacity * 100)}%`;
                deleteItemBtn.style.display = 'flex';
                document.getElementById('delete-separator').style.display = 'block';
            } else {
                opacitySliderContainer.style.display = 'none';
                opacitySeparator.style.display = 'none';
                deleteItemBtn.style.display = 'none';
                document.getElementById('delete-separator').style.display = 'none';
            }

            contextMenu.style.left = `${e.clientX}px`; 
            contextMenu.style.top = `${e.clientY}px`; 
            contextMenu.style.display = 'block';
        }

        // --- FILE & PROJECT HANDLING ---

        function confirmNewBoard() {
            if (items.length > 0) {
                showConfirmationModal();
            } else {
                resetBoard();
            }
        }

        function resetBoard() {
            items = [];
            selectedItems = [];
            cameraOffset = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
            cameraZoom = 1;
            historyStack = [];
            historyIndex = -1;
            saveStateForUndo(); // Save the new empty state
            currentProjectName = 'moodboard';
            updateSelectionToolbar();
            updateLeftBarState();
        }

        function showConfirmationModal() {
            confirmationModalOverlay.style.display = 'flex';
        }

        function hideConfirmationModal() {
            confirmationModalOverlay.style.display = 'none';
        }

        function saveAsPng() {
            if (items.length === 0) return;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            items.forEach(item => {
                const box = getItemBoundingBox(item);
                minX = Math.min(minX, box.x); minY = Math.min(minY, box.y);
                maxX = Math.max(maxX, box.x + box.width); maxY = Math.max(maxY, box.y + box.height);
            });
            const padding = 50;
            const exportWidth = maxX - minX + padding * 2;
            const exportHeight = maxY - minY + padding * 2;
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = exportWidth; exportCanvas.height = exportHeight;
            const exportCtx = exportCanvas.getContext('2d');
            exportCtx.fillStyle = canvasBackgroundColor;
            exportCtx.fillRect(0, 0, exportWidth, exportHeight);
            exportCtx.translate(-minX + padding, -minY + padding);
            items.forEach(item => {
                exportCtx.save();
                exportCtx.globalAlpha = item.opacity ?? 1;
                if (showDropShadow) { exportCtx.shadowColor = 'rgba(0,0,0,0.4)'; exportCtx.shadowBlur = 15; exportCtx.shadowOffsetX = 4; exportCtx.shadowOffsetY = 4; }
                if (item.type === 'image') {
                    const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
                    exportCtx.translate(centerX, centerY); exportCtx.rotate(item.rotation); exportCtx.translate(-centerX, -centerY);
                    exportCtx.drawImage(item.img, item.x, item.y, item.width, item.height);
                } else if (item.type === 'arrow') {
                    drawArrow(exportCtx, item);
                } else if (item.type === 'text') {
                    drawTextItem(exportCtx, item);
                } else if (item.type === 'box') {
                    drawBoxItem(exportCtx, item);
                }
                exportCtx.restore();
            });
            const link = document.createElement('a');
            link.download = 'moodboard.png';
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        }

        function saveProject() {
            const projectState = {
                items: items.map(item => {
                    if (item.type === 'image') {
                        return { ...item, img: item.img.src }; // Convert image to data URL string
                    }
                    return item;
                }),
                cameraOffset, cameraZoom, canvasBackgroundColor, accentColor, gridColor,
                showGrid, snapToGrid, showDropShadow, gridSize, gridOpacity
            };
            const blob = new Blob([JSON.stringify(projectState, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `${currentProjectName}.json`;
            link.click();
            URL.revokeObjectURL(link.href);
        }

        function loadProject(projectJson) {
            try {
                const state = JSON.parse(projectJson);
                cameraOffset = state.cameraOffset;
                cameraZoom = state.cameraZoom;
                canvasBackgroundColor = state.canvasBackgroundColor;
                accentColor = state.accentColor;
                gridColor = state.gridColor;
                showGrid = state.showGrid;
                snapToGrid = state.snapToGrid;
                showDropShadow = state.showDropShadow;
                gridSize = state.gridSize;
                gridOpacity = state.gridOpacity;
                
                items = [];
                selectedItems = [];
                
                // Recreate items, especially Image objects
                state.items.forEach(itemState => {
                    const newItem = { ...(itemState.opacity !== undefined ? {} : { opacity: 1 }), ...itemState };
                    if (newItem.type === 'image') {
                        const img = new Image();
                        items.push({ ...newItem, img: img });
                        img.src = newItem.img;
                    } else {
                        items.push(newItem);
                    }
                });
                
                // Update UI to reflect loaded settings
                bgColorPicker.value = canvasBackgroundColor;
                accentColorPicker.value = accentColor;
                gridColorPicker.value = gridColor;
                showGridToggle.checked = showGrid;
                snapGridToggle.checked = snapToGrid;
                dropShadowToggle.checked = showDropShadow;
                gridSizeSlider.value = gridSize;
                gridOpacitySlider.value = gridOpacity;
                historyStack = [];
                historyIndex = -1;
                updateUIColors();
                saveStateForUndo(); // Save this loaded state as the first undo point

            } catch (error) {
                console.error("Failed to load project:", error);
                alert("Sorry, this does not appear to be a valid project file.");
            }
        }

        function handleImageUpload(event) {
            if (!event.target.files) return;
            const worldPos = screenToWorld({x: canvas.width / 2, y: canvas.height / 2});
            processFiles(event.target.files, worldPos);
            imageInput.value = '';
        }

        function handleProjectUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                loadProject(e.target.result);
                currentProjectName = file.name.split('.').slice(0, -1).join('.');
            };
            reader.readAsText(file);
            projectInput.value = '';
        }

        function handlePaste(e) {
            const files = Array.from(e.clipboardData.items)
                .filter(item => item.type.indexOf('image') !== -1)
                .map(item => item.getAsFile());
            if (files.length > 0) processFiles(files, screenToWorld({ x: canvas.width / 2, y: canvas.height / 2 }));
        }
        function handleDragOver(e) { e.preventDefault(); canvas.style.outline = `2px dashed ${accentColor}`; canvas.style.outlineOffset = '-10px'; }
        function handleDragLeave(e) { e.preventDefault(); canvas.style.outline = 'none'; }
        
        function handleDrop(e) {
            e.preventDefault();
            handleDragLeave(e);
            if (!e.dataTransfer.files) return;
            
            const file = e.dataTransfer.files[0];
            if (file && (file.name.endsWith('.json') || file.name.endsWith('.mood'))) {
                 const reader = new FileReader();
                 reader.onload = (ev) => {
                    loadProject(ev.target.result);
                    currentProjectName = file.name.split('.').slice(0, -1).join('.');
                 };
                 reader.readAsText(file);
            } else {
                 processFiles(e.dataTransfer.files, screenToWorld({ x: e.clientX, y: e.clientY }));
            }
        }

        function processFiles(files, worldPos) {
             Array.from(files).forEach((file, index) => {
                if (!file.type.startsWith('image/')) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const aspectRatio = img.width / img.height; 
                        const newWidth = 250, newHeight = newWidth / aspectRatio;
                        items.push({ id: Date.now() + index, type: 'image', img: img, x: worldPos.x - (newWidth / 2) + (index * 20), y: worldPos.y - (newHeight / 2) + (index * 20), width: newWidth, height: newHeight, rotation: 0, isPinned: false, opacity: 1 });
                        bringSelectedToFront();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
            setTimeout(saveStateForUndo, 500); // Wait for images to likely have loaded
        }

        // --- ITEM & SELECTION LOGIC ---

        function deleteSelectedItems() {
            if(selectedItems.length > 0) {
                const idsToDelete = new Set(selectedItems.map(item => item.id));
                items = items.filter(item => !idsToDelete.has(item.id));
                selectedItems = [];
                updateSelectionToolbar();
                updateLeftBarState();
                saveStateForUndo();
            }
        }
        
        function bringSelectedToFront() {
            if (selectedItems.length === 0) return;
            const selectedIds = new Set(selectedItems.map(item => item.id));
            const toFront = items.filter(item => selectedIds.has(item.id));
            const remaining = items.filter(item => !selectedIds.has(item.id));
            items = [...remaining, ...toFront];
            saveStateForUndo();
        }

        function sendSelectedToBack() {
            if (selectedItems.length === 0) return;
            const selectedIds = new Set(selectedItems.map(item => item.id));
            const toBack = items.filter(item => selectedIds.has(item.id));
            const remaining = items.filter(item => !selectedIds.has(item.id));
            items = [...toBack, ...remaining];
            saveStateForUndo();
        }

        function toggleBoxStyle() {
            let changed = false;
            selectedItems.forEach(item => {
                if (item.type === 'box') {
                    item.style = item.style === 'fill' ? 'outline' : 'fill';
                    changed = true;
                }
            });
            if (changed) {
                saveStateForUndo();
            }
        }

        function autoAlignSelection() {
            if (selectedItems.length < 2) return;

            const padding = 20;

            let totalWidth = 0, totalHeight = 0;
            selectedItems.forEach(item => {
                totalWidth += getItemBoundingBox(item).width;
                totalHeight += getItemBoundingBox(item).height;
            });
            const avgWidth = totalWidth / selectedItems.length;
            const avgHeight = totalHeight / selectedItems.length;
            
            const numCols = Math.ceil(Math.sqrt(selectedItems.length));
            const collectiveBox = getCollectiveBoundingBox(selectedItems);
            const startX = collectiveBox.x;
            const startY = collectiveBox.y;

            selectedItems.forEach((item, index) => {
                const row = Math.floor(index / numCols);
                const col = index % numCols;

                const newX = startX + col * (avgWidth + padding);
                const newY = startY + row * (avgHeight + padding);
                
                const deltaX = newX - item.x;
                const deltaY = newY - item.y;
                
                item.x += deltaX;
                item.y += deltaY;

                if (item.type === 'arrow') {
                    item.startX += deltaX;
                    item.startY += deltaY;
                    item.endX += deltaX;
                    item.endY += deltaY;
                }
            });
            saveStateForUndo();
        }


        // --- UI & STATE MANAGEMENT ---

        function toggleHelpFooter() {
            isHelpOpen = !isHelpOpen;
            instructionsFooter.classList.toggle('closed', !isHelpOpen);
        }

        function updateLeftBarState() {
            alignBtn.disabled = selectedItems.length < 2;
        }

        function updateUIColors() {
            const [accentH, accentS] = hexToHsl(accentColor);
            const [, , bgL] = hexToHsl(canvasBackgroundColor);
            const uiLuminosity = Math.max(0.1, Math.min(0.9, 1.0 - bgL));
            const uiSaturation = Math.min(accentS, 0.6); 
            const [uiR, uiG, uiB] = hslToRgb(accentH, uiSaturation, uiLuminosity);
            const hoverLuminosity = uiLuminosity + (uiLuminosity > 0.5 ? -0.1 : 0.1);
            const [hvrR, hvrG, hvrB] = hslToRgb(accentH, uiSaturation, hoverLuminosity);
            
            const root = document.documentElement.style;
            root.setProperty('--bg-page', canvasBackgroundColor);
            root.setProperty('--bg-ui', `rgba(${uiR}, ${uiG}, ${uiB}, 0.5)`);
            root.setProperty('--bg-ui-hover', `rgba(${hvrR}, ${hvrG}, ${hvrB}, 0.65)`);
            root.setProperty('--text-color', uiLuminosity > 0.55 ? '#0f172a' : '#f8fafc');
            root.setProperty('--text-color-light', uiLuminosity > 0.55 ? '#334155' : '#94a3b8');
            root.setProperty('--border-color', hslToHex(accentH, uiSaturation, uiLuminosity + (uiLuminosity > 0.5 ? -0.15 : 0.15)));
            root.setProperty('--switch-bg-checked', accentColor);
        }

        function setCurrentTool(tool) {
            currentTool = currentTool === tool ? null : tool;
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            if (currentTool === 'arrow') addArrowBtn.classList.add('active');
            if (currentTool === 'text') addTextBtn.classList.add('active');
            if (currentTool === 'box') addBoxBtn.classList.add('active');
        }

        function setActiveGizmo(gizmo) { 
            activeGizmo = activeGizmo === gizmo ? null : gizmo; 
            updateSelectionToolbar(); 
        }
        function togglePin() { 
            if (selectedItems.length > 0) { 
                const newState = !selectedItems[0].isPinned;
                selectedItems.forEach(item => item.isPinned = newState);
                updateSelectionToolbar(); 
                saveStateForUndo();
            } 
        }

        function updateSelectionToolbar() {
            const hasBox = selectedItems.some(item => item.type === 'box');
            const canTransform = selectedItems.length === 1 && selectedItems[0].type !== 'arrow';
            const canPin = selectedItems.length > 0;
            const canLayer = selectedItems.length > 0;

            if (selectedItems.length > 0) {
                selectionToolbar.style.display = 'flex';
                toggleBoxStyleBtn.style.display = hasBox ? 'flex' : 'none';
                scaleBtn.style.display = canTransform ? 'flex' : 'none';
                rotateBtn.style.display = canTransform ? 'flex' : 'none';
                pinBtn.style.display = canPin ? 'flex' : 'none';
                bringFrontBtn.style.display = canLayer ? 'flex' : 'none';
                sendBackBtn.style.display = canLayer ? 'flex' : 'none';
                
                scaleBtn.classList.toggle('active', activeGizmo === 'scale');
                rotateBtn.classList.toggle('active', activeGizmo === 'rotate');
                pinBtn.classList.toggle('pinned', canPin && selectedItems.every(i => i.isPinned));

                const isSingleBox = selectedItems.length === 1 && selectedItems[0].type === 'box';
                if(isSingleBox && !selectedItems[0].isPinned) {
                    boxColorPickerContainer.style.display = 'block';
                    boxColorPicker.value = selectedItems[0].color;
                } else {
                    boxColorPickerContainer.style.display = 'none';
                }

            } else { 
                selectionToolbar.style.display = 'none';
                boxColorPickerContainer.style.display = 'none';
                activeGizmo = null; 
            }
        }

        function updateToolbarPosition() {
             if (selectedItems.length > 0) {
                const collectiveBox = getCollectiveBoundingBox(selectedItems);
                const screenPos = worldToScreen({ x: collectiveBox.x + collectiveBox.width / 2, y: collectiveBox.y + collectiveBox.height });
                selectionToolbar.style.left = `${screenPos.x}px`;
                selectionToolbar.style.top = `${screenPos.y}px`;
                
                if(selectedItems.length === 1 && selectedItems[0].type === 'box' && !selectedItems[0].isPinned){
                    const item = selectedItems[0];
                    const boxTopLeft = worldToScreen({x: item.x, y: item.y});
                    boxColorPickerContainer.style.left = `${boxTopLeft.x - 12}px`;
                    boxColorPickerContainer.style.top = `${boxTopLeft.y - 12}px`;
                }
            }
        }

        function editText(item) {
            currentlyEditingText = item;
            item.isHidden = true;
            const screenPos = worldToScreen({ x: item.x, y: item.y });
            const screenWidth = item.width * cameraZoom, screenHeight = item.height * cameraZoom;
            Object.assign(textEditor.style, {
                display: 'block', left: `${screenPos.x}px`, top: `${screenPos.y}px`,
                width: `${screenWidth}px`, height: 'auto',
                transform: `rotate(${item.rotation}rad)`, transformOrigin: 'top left',
                color: accentColor, backgroundColor: hexToRgba(accentColor, 0.1),
                fontSize: `${item.fontSize * cameraZoom}px`,
            });
            textEditor.value = item.text === "Type..." ? "" : item.text;
            textEditor.focus();
            autoResizeTextEditor();
            selectedItems = [];
            updateToolbarPosition();
            updateLeftBarState();
        }

        function finishEditingText() {
            if (currentlyEditingText) {
                currentlyEditingText.text = textEditor.value.trim() || "Type...";
                // Recalculate width/height based on new text content
                ctx.font = `bold ${currentlyEditingText.fontSize}px 'Inter', sans-serif`;
                const lines = textEditor.value.split('\n');
                let maxWidth = 0;
                lines.forEach(line => {
                    const metrics = ctx.measureText(line);
                    if (metrics.width > maxWidth) maxWidth = metrics.width;
                });
                currentlyEditingText.width = maxWidth + 20; // Add padding
                currentlyEditingText.height = textEditor.scrollHeight / cameraZoom;

                currentlyEditingText.isHidden = false;
                selectedItems = [currentlyEditingText];
                saveStateForUndo();
                currentlyEditingText = null;
            }
            textEditor.style.display = 'none';
        }
        
        function autoResizeTextEditor() {
            textEditor.style.height = 'auto';
            textEditor.style.height = textEditor.scrollHeight + 'px';
        }

        // --- HISTORY & UNDO FUNCTIONS ---

        function saveStateForUndo() {
            const stateToSave = JSON.stringify(items.map(item => {
                if (item.type === 'image') return { ...item, img: item.img.src };
                return item;
            }));

            if (historyIndex < historyStack.length - 1) {
                historyStack = historyStack.slice(0, historyIndex + 1);
            }

            if (historyStack.length > 0 && historyStack[historyStack.length - 1] === stateToSave) return;

            historyStack.push(stateToSave);
            historyIndex++;

            if (historyStack.length > HISTORY_LIMIT) {
                historyStack.shift();
                historyIndex--;
            }
        }
        
        function loadStateFromHistory(stateJson) {
            const historyItems = JSON.parse(stateJson);
            items = [];
            selectedItems = [];
            updateSelectionToolbar();
            updateLeftBarState();

            historyItems.forEach(itemState => {
                if (itemState.type === 'image') {
                    const img = new Image();
                    items.push({ ...itemState, img: img });
                    img.src = itemState.img;
                } else {
                    items.push(itemState);
                }
            });
        }

        function undoLastAction() {
            if (historyIndex > 0) {
                historyIndex--;
                const previousStateJson = historyStack[historyIndex];
                loadStateFromHistory(previousStateJson);
            }
        }

        function redoLastAction() {
            if (historyIndex < historyStack.length - 1) {
                historyIndex++;
                const nextStateJson = historyStack[historyIndex];
                loadStateFromHistory(nextStateJson);
            }
        }


        // --- UTILITY FUNCTIONS ---
        
        function getEventLocation(e) { return { x: e.clientX, y: e.clientY }; }
        function screenToWorld(p) { return { x: (p.x - canvas.width / 2) / cameraZoom - cameraOffset.x + canvas.width / 2, y: (p.y - canvas.height / 2) / cameraZoom - cameraOffset.y + canvas.height / 2 }; }
        function worldToScreen(p) { return { x: (p.x + cameraOffset.x - canvas.width / 2) * cameraZoom + canvas.width / 2, y: (p.y + cameraOffset.y - canvas.height / 2) * cameraZoom + canvas.height / 2 }; }
        
        function getItemAtPosition(pos) {
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                if (item.type === 'arrow') {
                    if (Math.sqrt(distToSegmentSquared(pos, {x: item.startX, y: item.startY}, {x: item.endX, y: item.endY})) < 10 / cameraZoom) return item;
                } else { 
                    const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
                    const dx = pos.x - centerX, dy = pos.y - centerY, angle = -item.rotation;
                    const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
                    const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);
                    if (rotatedX > -item.width / 2 && rotatedX < item.width / 2 && rotatedY > -item.height / 2 && rotatedY < item.height / 2) return item;
                }
            }
            return null;
        }

        function getGizmoAtPosition(worldPos) {
            if (selectedItems.length !== 1 || !activeGizmo) return null;
            const item = selectedItems[0];
            if (item.isPinned || item.type === 'arrow') return null;
            
            const handleSize = 14 / cameraZoom, centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
            if (activeGizmo === 'rotate') {
                const rotDX = item.width / 2, rotDY = -item.height / 2 - 20 / cameraZoom;
                const rotX = rotDX * Math.cos(item.rotation) - rotDY * Math.sin(item.rotation);
                const rotY = rotDX * Math.sin(item.rotation) + rotDY * Math.cos(item.rotation);
                if (Math.hypot(worldPos.x - (centerX + rotX), worldPos.y - (centerY + rotY)) < handleSize) return 'rotate';
            } else if (activeGizmo === 'scale') {
                const scaleDX = item.width / 2, scaleDY = item.height / 2;
                const scaleX = scaleDX * Math.cos(item.rotation) - scaleDY * Math.sin(item.rotation);
                const scaleY = scaleDX * Math.sin(item.rotation) + scaleDY * Math.cos(item.rotation);
                if (Math.hypot(worldPos.x - (centerX + scaleX), worldPos.y - (centerY + scaleY)) < handleSize) return 'scale';
            }
            return null;
        }

        function getArrowHandleAtPosition(worldPos) {
            if (selectedItems.length !== 1) return null;
            const item = selectedItems[0];
            if (item.isPinned || item.type !== 'arrow') return null;
            const handleRadius = 12 / cameraZoom;
            if (Math.hypot(worldPos.x - item.startX, worldPos.y - item.startY) < handleRadius) return 'start';
            if (Math.hypot(worldPos.x - item.endX, worldPos.y - item.endY) < handleRadius) return 'end';
            return null;
        }

        function getCollectiveBoundingBox(itemList) {
            if (itemList.length === 0) return { x: 0, y: 0, width: 0, height: 0 };
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            itemList.forEach(item => {
                const box = getItemBoundingBox(item);
                minX = Math.min(minX, box.x);
                minY = Math.min(minY, box.y);
                maxX = Math.max(maxX, box.x + box.width);
                maxY = Math.max(maxY, box.y + box.height);
            });
            return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
        }

        function getItemBoundingBox(item) {
            if (item.type === 'arrow') {
                return { x: Math.min(item.startX, item.endX), y: Math.min(item.startY, item.endY), width: Math.abs(item.startX - item.endX), height: Math.abs(item.startY - item.endY) };
            }
            const w = item.width, h = item.height, cx = item.x + w / 2, cy = item.y + h / 2, angle = item.rotation;
            const cos = Math.cos(angle), sin = Math.sin(angle);
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            [{x:-w/2,y:-h/2},{x:w/2,y:-h/2},{x:w/2,y:h/2},{x:-w/2,y:h/2}].forEach(c => {
                const rotX = c.x * cos - c.y * sin + cx, rotY = c.x * sin + c.y * cos + cy;
                minX = Math.min(minX, rotX); minY = Math.min(minY, rotY);
                maxX = Math.max(maxX, rotX); maxY = Math.max(maxY, rotY);
            });
            return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
        }
        function rectsIntersect(r1, r2) { return !(r2.x > r1.x + r1.width || r2.x + r2.width < r1.x || r2.y > r1.y + r1.height || r2.y + r2.height < r1.y); }
        function getNormalizedSelectionBox() { return { x: Math.min(selectionBox.startX, selectionBox.endX), y: Math.min(selectionBox.startY, selectionBox.endY), width: Math.abs(selectionBox.startX - selectionBox.endX), height: Math.abs(selectionBox.startY - selectionBox.endY) }; }
        function hexToRgba(hex, alpha) {
            let r=0,g=0,b=0;
            if(hex.length==4){r="0x"+hex[1]+hex[1];g="0x"+hex[2]+hex[2];b="0x"+hex[3]+hex[3];}else if(hex.length==7){r="0x"+hex[1]+hex[2];g="0x"+hex[3]+hex[4];b="0x"+hex[5]+hex[6];}
            return`rgba(${+r},${+g},${+b},${alpha})`;
        }
        function distSq(p1,p2){return Math.pow(p1.x-p2.x,2)+Math.pow(p1.y-p2.y,2);}
        function distToSegmentSquared(p,v,w){
            const l2=distSq(v,w); if(l2===0)return distSq(p,v);
            let t=((p.x-v.x)*(w.x-v.x)+(p.y-v.y)*(w.y-v.y))/l2;
            t=Math.max(0,Math.min(1,t));
            return distSq(p,{x:v.x+t*(w.x-v.x),y:v.y+t*(w.y-v.y)});
        }
        function invertColor(hex){
            if(hex.indexOf('#')===0)hex=hex.slice(1); if(hex.length===3)hex=hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
            if(hex.length!==6)return'#ffffff';
            const r=(255-parseInt(hex.slice(0,2),16)).toString(16),g=(255-parseInt(hex.slice(2,4),16)).toString(16),b=(255-parseInt(hex.slice(4,6),16)).toString(16);
            return'#'+padZero(r)+padZero(g)+padZero(b);
        }
        function hslToRgb(h,s,l){let c=(1-Math.abs(2*l-1))*s,x=c*(1-Math.abs((h/60)%2-1)),m=l-c/2,r=0,g=0,b=0;if(0<=h&&h<60){r=c;g=x;b=0;}else if(60<=h&&h<120){r=x;g=c;b=0;}else if(120<=h&&h<180){r=0;g=c;b=x;}else if(180<=h&&h<240){r=0;g=x;b=c;}else if(240<=h&&h<300){r=x;g=0;b=c;}else if(300<=h&&h<360){r=c;g=0;b=x;}return[Math.round((r+m)*255),Math.round((g+m)*255),Math.round((b+m)*255)];}
        function hexToHsl(H){let r=0,g=0,b=0;if(H.length==4){r="0x"+H[1]+H[1];g="0x"+H[2]+H[2];b="0x"+H[3]+H[3];}else if(H.length==7){r="0x"+H[1]+H[2];g="0x"+H[3]+H[4];b="0x"+H[5]+H[6];}r/=255;g/=255;b/=255;let cmin=Math.min(r,g,b),cmax=Math.max(r,g,b),delta=cmax-cmin,h=0,s=0,l=0;if(delta==0)h=0;else if(cmax==r)h=((g-b)/delta)%6;else if(cmax==g)h=(b-r)/delta+2;else h=(r-g)/delta+4;h=Math.round(h*60);if(h<0)h+=360;l=(cmax+cmin)/2;s=delta==0?0:delta/(1-Math.abs(2*l-1));return[h,s,l];}
        function hslToHex(h,s,l){let c=(1-Math.abs(2*l-1))*s,x=c*(1-Math.abs((h/60)%2-1)),m=l-c/2,r=0,g=0,b=0;if(0<=h&&h<60){r=c;g=x;b=0;}else if(60<=h&&h<120){r=x;g=c;b=0;}else if(180<=h&&h<180){r=0;g=c;b=x;}else if(180<=h&&h<240){r=0;g=x;b=c;}else if(240<=h&&h<300){r=x;g=0;b=c;}else if(300<=h&&h<360){r=c;g=0;b=x;}r=Math.round((r+m)*255).toString(16);g=Math.round((g+m)*255).toString(16);b=Math.round((b+m)*255).toString(16);if(r.length==1)r="0"+r;if(g.length==1)g="0"+g;if(b.length==1)b="0"+b;return"#"+r+g+b;}
        function padZero(str,len){len=len||2;const zeros=new Array(len+1).join('0');return(zeros+str).slice(-len);}
        function adjustZoom(e,z){
            if(isDragging)return;
            const wpb=screenToWorld(getEventLocation(e));
            cameraZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, cameraZoom * (1 + z)));
            const wpa=screenToWorld(getEventLocation(e));
            cameraOffset.x+=wpa.x-wpb.x;cameraOffset.y+=wpa.y-wpb.y;
        }

        // --- INITIALIZATION ---
        
        // Set initial camera position to center the view
        cameraOffset = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        resizeCanvas();
        setupEventListeners();
        canvas.style.backgroundColor=canvasBackgroundColor;
        updateUIColors();
        saveStateForUndo(); // Save the initial empty state
        gameLoop();
    </script>
</body>
</html>

